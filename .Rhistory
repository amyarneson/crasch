fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
results$estSummary$I
i =11
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 12
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
empties
results$empties
results$scoresOrig[,c(6,12)]
table(results$scoresOrig[,6])
table(results$scoresOrig[,12])
View(itemInfo)
results$empties
View(GC_scores)
table(results$scoresOrig[,1])
table(results$scoresOrig[,2])
table(results$scoresOrig[,3])
table(results$scoresOrig[,4])
table(results$scoresOrig[,5])
table(results$scoresOrig[,6])
table(results$scoresOrig[,7])
table(results$scoresOrig[,8])
table(results$scoresOrig[,9])
table(results$scoresOrig[,10])
table(results$scoresOrig[,11])
table(results$scoresOrig[,12])
wide = results$scoresOrig
itemScoreInfo = t(itemInfo[,6:ncol(itemInfo)])
itemScoreInfo
I = ncol(wide)
item.list = list()
i = 1
which(!which(itemScoreInfo[,i]) %in% wide[,i])
for (i in 1:I) {
item.list[[i]] <- which(!(which(itemScoreInfo[,i]) %in% wide[,i]))
}
item.list
i = 6
which(!(which(itemScoreInfo[,i]) %in% wide[,i]))
itemScoreInfo[,i]
wide[,i]
which(itemScoreInfo[,i])
wide[,i]
which(itemScoreInfo[,i])
unique(wide[,i])
?unique
which(itemScoreInfo[,i]) %in% unique(wide[,i])
which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
i = 12
which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
i = 2
which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
empty.cats <- function(wide,
itemScoreInfo) {
I = ncol(wide)
item.list = list()
for (i in 1:I) {
item.list[[i]] <- which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
}
return(item.list)
}
devtools::load_all
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
GC_cons = read.csv("GC_cons (1).csv", stringsAsFactors = FALSE)
GC_item = read.csv("GC_item (1).csv", stringsAsFactors = FALSE)
GC_scores = read.csv("GC_wide (1).csv", row.names = 1, stringsAsFactors = FALSE)
#GC_vars = read.csv("GC_vars (1).csv", row.names = 1, stringsAsFactors = FALSE)
GC_analysis = craschR(scores = GC_scores, itemInfo = GC_item,
consInfo = GC_cons, writeout = TRUE)
wm(GC_analysis) # organized in item order
wm(GC_analysis, byCat = TRUE) # organized in construct category order
setwd("C:/Users/Amy/Desktop/Laura2")
library(crasch)
GC_cons = read.csv("GC_cons (1).csv", stringsAsFactors = FALSE)
GC_item = read.csv("GC_item (1).csv", stringsAsFactors = FALSE)
GC_scores = read.csv("GC_wide (1).csv", row.names = 1, stringsAsFactors = FALSE)
#GC_vars = read.csv("GC_vars (1).csv", row.names = 1, stringsAsFactors = FALSE)
GC_analysis = craschR(scores = GC_scores, itemInfo = GC_item,
consInfo = GC_cons, writeout = TRUE)
wm(GC_analysis) # organized in item order
wm(GC_analysis, byCat = TRUE) # organized in construct category order
library(crasch)
cons <- ADMcons[ADMcons$cons.ID %in% c(10001, 10002, 10003), ]
item <- ADMitem[ADMitem$cons.ID %in% cons$cons.ID, ]
item[item$item.ID %in% c(30037, 30038), c(7:9, 11, 14:15)] = TRUE
scores <- ADMlong[ADMlong$item.ID %in% item$item.ID, ]
rm(list = ls())
ADM3cons <- ADMcons[ADMcons$cons.ID %in% c(10001, 10002, 10003), ]
ADM3item <- ADMitem[ADMitem$cons.ID %in% ADM3cons$cons.ID, ]
ADM3item[ADM3item$item.ID %in% c(30037, 30038), c(7:9, 11, 14:15)] = TRUE
ADM3long <- ADMlong[ADMlong$item.ID %in% ADM3item$item.ID, ]
devtools::use_data(ADM3cons)
devtools::use_data(ADM3long)
devtools::use_data(ADM3item)
rm(list = ls())
ADM3analysis <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons,
longForm = TRUE, writeout = TRUE)
library(crasch)
devtools::load_all()
install.packages("testthat")
devtools::load_all()
ADM3analysis <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons,
longForm = TRUE, writeout = TRUE)
devtools::use_data(ADM3analysis)
pers.hist(ADM3analysis)
?pers.hist
KIDMAP(ADM3analysis, dim = 1)
KIDMAP(ADM3analysis, dim = 1, personID = 2)
View(ADM3analysis$scoresOrig)
KIDMAP(ADM3analysis, dim = 1, personID = 101)
?craschR
ADM3consecutive <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons, longForm = TRUE,
consecutive = TRUE, writeout = TRUE)
devtools::use_data(ADM3consecutive)
names(ADM3consecutive)
ADM3$estSummary
ADM3consecutive$estSummary
KIDMAP(ADM3consecutive, dim = 1, personID = 101)
pers.hist(ADM3consecutive, dim = 3)
pers.hist(ADM3analysis, dim = 3)
pers.hist(ADM3consecutive)
pers.hist(ADM3analysis)
KIDMAP(ADM3analysis, personID = 101, dim = 1)
devtools::load_all()
KIDMAP(ADM3analysis, personID = 101, dim = 1)
KIDMAP(ADM3consecutive, personID = 101, dim = 1)
KIDMAP(ADM3consecutive, personID =  101)
KIDMAP(ADM3consecutive, personID =  101)
devtools::load_all()
KIDMAP(ADM3consecutive, personID =  101)
devtools::load_all()
KIDMAP(ADM3consecutive, personID =  101)
?infit.MNSQ
infit.MNSQ(ADM3analysis)
infit.MNSQ(ADM3consecutive)
CPC.graph(ADM3analysis)
CPC.graph(ADM3consecutive)
ICC.graph(ADM3analysis)
ICC.graph(ADM3consecutive)
info.graph(ADM3analysis)
info.graph(ADM3consecutive)
wm(ADM3analysis)
wm(ADM3consecutive)
item.analysis(ADM3analysis)
item.analysis(ADM3consecutive)
results = ADM3analysis
checkResults(results)
checkWrite(writeout, fileSuffix)
byItem = cbind(Item_no = 1:results$estSummary$I,
Construct = results$consInfo$short.name[
match(results$itemInfo$cons.ID, results$consInfo$cons.ID)],
Count = colSums(!is.na(results$scoresRecoded)),
Missing = colSums(is.na(results$scoresRecoded)),
Estimate = results$itemPars[,1],
SE_est = results$itemSEs[,1],
results$itemFit[1:nrow(results$itemPars), c(2:4,6:8)]
)
View(byItem)
persProp = results$persRaw / results$persMax
View(persProp)
if (ncol(results$itemThres) > 1) {
K_total = sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)]))
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
start <- 1
for (i in 1:results$estSummary$I) {
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
}
} else if (ncol(results$itemThres) == 1) {
# create the byStep table (for dichotomous items)
K_total = 2 * results$estSummary$I
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
for(i in 1:results$estSummary$I) {
fill = c(2*i - 1, 2*i)
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
# item and category names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], 2)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], 2)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# there will be no empty categories (if there were, tam() would have failed)
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:1
# location estimates and standard errors
byStep$Estimate[fill[2]] = results$itemPars[i,1]
byStep$SE_est[fill[2]] = results$itemSEs[i,1]
# thresholds
byStep$Threshold[fill[2]] = results$itemThres[i]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
}
}
ncol(results$itemThres) > 1
K_total = sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)]))
colSums(results$itemInfo[,6:ncol(results$itemInfo)])
?colSums
K_total = sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)],
na.rm = TRUE))
devtools::load_all()
item.analysis(ADM3analysis)
item.analysis(ADM3consecutive)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
View(byStep)
start <- 1
1:results$estSummary$I
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
i = 1
for (i in 1:results$estSummary$I) {
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
}
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)])
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]),
na.rm = TRUE)
fill = c(start:(start + K_i - 1))
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
byStep$Count[fill] = table(results$scoresRecoded[,i])
byStep$Score[fill] = 0:(length(fill) - 1)
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]), cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
persProp[!is.na(results$scoresRecoded[,i]), cons]
!is.na(results$scoresRecoded[, i])
results$persRaw
results$persMax
results$scoresRecoded[, i]
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[, i]), cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[, i]), 1],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
if (!results$estSummary$consecutive & results$estSummary$D > 1) {
cons0 = 1
# non-consecutive multiD analysis should calc w/total score
} else {
cons0 = cons
# consecutive "multiD" analysis should calc w/subscore
}
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[, i]), cons0],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
View(ADM3analysis$persRaw)
View(ADM3consecutive$persRaw)
devtools::load_all()
ADM3analysis$persRaw
ADM3analysis <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons, longForm = TRUE, writeout = TRUE)
ADM3analysis$persRaw
ADM3analysis$persMax
devtools::use_data(ADM3analysis, overwrite = TRUE)
item.analysis(ADM3analysis)
devtools::check()
devtools::load_all()
item.analysis(ADM3analysis)
item.analysis(ADM3consecutive)
crasch::item.analysis(ADM3consecutive, writeout = TRUE)
ADM3consecutive <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons, longForm = TRUE,
consecutive = TRUE, writeout = TRUE)
