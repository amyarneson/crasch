} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette)) & length(palette)==2) {
color <- palette
} else {
stop('Invalid palette argument.')
}
layout(matrix(1, nrow = 1))
dotchart(x = rev(toPlot[,1]), rev(row.names(toPlot)),
main = "Infit Mean Squares", xlab = "Infit MNSQ", ylab = "",
xlim = c(min(.7, min(toPlot[,1])), max(1.4, max(toPlot[,1]))),
pch = ".")
observed = FALSE
minCell = 8
focusTheta = c(-2,0,2)
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
itemThres <- results$itemThres[itemOrder,]
} else {
stop('itemOrder must be a numeric vector or NULL.')
}
I <- nrow(itemInfo)
for (i in 1:I) {
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (length(palette) == 1) {
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
fillcol = "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(max(K_i,3), palette)
fillcol = "white"
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
fillcol = "gray"
}  else {
stop('Invalid palette argument.')
}
} else {
stop('Invalid palette argument.')
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 1:K_i) {
if (observed) {
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,i]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
} else {
linecol = "black"
vlinecol = "grey"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
}
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
} else {
abline(v = focusTheta, col = vlinecol, lty = 2, lwd = 2)
for (a in 1:length(focusTheta)) {
bounds <- boot::inv.logit(focusTheta[a] - thres)
L <- placement <- rep(NA, length(bounds) + 1)
for (k in 0:K_i) {
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K_i) {
loBd = 0
} else {
loBd = bounds[k+1]
}
L[k+1] = paste0("p(",k,")=", round(upBd - loBd, 2))
placement[k+1] = mean(c(upBd, loBd))
}
points(x = rep(focusTheta[a], length(bounds)), y = bounds, pch=21,
bg = fillcol)
text(x = rep(focusTheta[a], length(bounds) + 1), y = placement,
labels = L, pos = 4, cex = .5)
}
}
}
}
itemInfo
nrow(itemInfo)
i = 1
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
itemThres
class(itemThres)
itemThres <- data.frame(results$itemThres[itemOrder,])
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
devtools::load_all()
CPC.graph(ADP, itemOrder = 1)
CPC.graph(ADP, itemOrder = 15)
CPC.graph(ADP, itemOrder = 14)
CPC.graph(ADP, itemOrder = 13)
CPC.graph(ADP, itemOrder = 12)
CPC.graph(ADP, itemOrder = 11)
CPC.graph(ADP, itemOrder = 10)
CPC.graph(ADP)
itemThres <- matrix(results$itemThres)
itemThres
itemThres <- results$itemThres[itemOrder,]
itemOrder = 1:3
itemThres <- results$itemThres[itemOrder,]
itemThres
class(itemThres)
itemOrder = 1
matrix(results$itemThres[itemOrder,])
results$itemThres[itemOrder,
]
matrix(results$itemThres[itemOrder,], nrow = 1)
?matrix
matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(itemThres)))
devtools::load_all()
CPC.graph(ADP, itemOrder = 10)
CPC.graph(ADP)
CPC.graph(ADP, itemOrder = 15)
CPC.graph(ADP, itemOrder = 13)
devtools::load_all()
ICC.graph(ADP, itemOrder = 13)
ICC.graph(ADP)
ICC.graph(ADP, itemOrder = 13)
mn.traj(ADP, itemOrder = 1:2)
mn.traj(ADP, itemOrder = 1)
results = ADP
itemOrder = 1
itemOrder = 13
palette = "BASS"
itemInfo <- results$itemInfo[itemOrder,]
itemInfo
scoresRecoded <- results$scoresRecoded[,itemOrder]
scoresRecoded
itemOrder = 1:2
scoresRecoded <- results$scoresRecoded[,itemOrder]
scoresRecoded
class(scoresRecoded)
results$scoresRecoded[,itemOrder]
itemOrder = 1
data.frame(results$scoresRecoded[,itemOrder])
row.names(scoresRecoded) = row.names(results$scoresRecoded)
scoresRecoded
scoresRecoded <- data.frame(results$scoresRecoded[,itemOrder])
row.names(scoresRecoded) = row.names(results$scoresRecoded)
scoresRecoded
colnames(scoresRecoded) = colnames(results$scoresRecoded)[itemOrder]
head(scoresRecoded)
devtools::load_all()
mn.traj(ADP, itemOrder = 13)
mn.traj(ADP)
mn.traj(ADP, itemOrder = 12:13)
devtools::build()
devtools::build()
devtools::load_all()
CPC.graph(ADP, itemOrder = c(1, 13))
results = ADP
itemOrder = 15
palette= "BASS"
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
if (length(itemOrder == 1)) {
itemThres <- matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(results$itemThres)))
} else {
itemThres <- results$itemThres[itemOrder,]
}
} else {
stop('Invalid itemOrder argument.')
}
itemOrder = 13
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
if (length(itemOrder == 1)) {
itemThres <- matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(results$itemThres)))
} else {
itemThres <- results$itemThres[itemOrder,]
}
} else {
stop('Invalid itemOrder argument.')
}
I <- nrow(itemInfo)
lty <- rep(1:4, 3)
if (identical(palette, "BASS")) {
color <- rep(c("#80b1d3", "darkgoldenrod1", "gray52"), 4)
} else if (length(palette) == 1) {
if (palette %in% row.names(brewer.pal.info)) {
color <- rep(brewer.pal(3, palette), 4)
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette)) & length(palette)==3) {
color <- rep(palette, 4)
} else {
stop('Invalid palette argument.')
}
i = 1
K_i <- sum(!is.na(itemThres[i,]))
if (K_i > 12) {
warning("Item ", i, " not graphed. Too many categories.")
} else {
thres <- c(-Inf, itemThres[i, !is.na(itemThres[i,])], Inf)
if (writeout) {
eval(parse(text = paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")))
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability", main="Category Characteristic Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 0:K_i) {
curve(boot::inv.logit(x - thres[k + 1]) - boot::inv.logit(x - thres[k + 2]),
from = -6, to = 6, add = TRUE, lwd = 2, lty = lty[k + 1],
col = color[k + 1])
}
cats <- as.logical(itemInfo[i, 6:ncol(itemInfo)])
# deal with empty categories
if (length(results$empties[[i]]) > 0) {
cats[results$empties[[i]]] = FALSE
}
par(xpd = TRUE)
legend(-6, .7, as.character(
results$consInfo[which(results$consInfo$cons.ID == itemInfo$cons.ID[i]),
4:ncol(results$consInfo)])[cats], lty = lty, lwd = 2,
col = color, cex = .6)
}
writeout = FALSE
if (K_i > 12) {
warning("Item ", i, " not graphed. Too many categories.")
} else {
thres <- c(-Inf, itemThres[i, !is.na(itemThres[i,])], Inf)
if (writeout) {
eval(parse(text = paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")))
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability", main="Category Characteristic Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 0:K_i) {
curve(boot::inv.logit(x - thres[k + 1]) - boot::inv.logit(x - thres[k + 2]),
from = -6, to = 6, add = TRUE, lwd = 2, lty = lty[k + 1],
col = color[k + 1])
}
cats <- as.logical(itemInfo[i, 6:ncol(itemInfo)])
# deal with empty categories
if (length(results$empties[[i]]) > 0) {
cats[results$empties[[i]]] = FALSE
}
par(xpd = TRUE)
legend(-6, .7, as.character(
results$consInfo[which(results$consInfo$cons.ID == itemInfo$cons.ID[i]),
4:ncol(results$consInfo)])[cats], lty = lty, lwd = 2,
col = color, cex = .6)
}
CPC.graph(ADP, itemOrder = c(1, 13))
devtools::load_all()
CPC.graph(ADP, itemOrder = c(1, 13))
devtools::build()
CPC.graph(ADP, itemOrder = 13
)
CPC.graph(SUP, itemOrder = 15)
CPC.graph(SUP, itemOrder = 15, observed = TRUE)
CPC.graph(SUP, itemOrder = c(1,15), observed = TRUE)
par(xpd = FALSE)
results = SUP
itemOrder = 15
observed = TRUE
palette = "BASS"
minCell = 8
focusTheta = c(-2,0,2)
if (!is.logical(observed)) {
stop('Invalid observed argument.')
}
if (!(is.numeric(minCell) & (minCell > 0) & (minCell %% 1 == 0))) {
stop('Invalid minCell argument.')
}
if (!is.numeric(focusTheta)) {
stop('Invalid focusTheta argument.')
}
if (minCell < 10 & observed) {
warning('Low cell counts (<10) will be graphed. Interpret with caution.')
}
par(xpd = FALSE)
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
if (length(itemOrder) == 1) {
itemThres <- matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(results$itemThres)))
} else {
itemThres <- results$itemThres[itemOrder,]
}
} else {
stop('itemOrder must be a numeric vector or NULL.')
}
I <- nrow(itemInfo)
I
i = 1
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (length(palette) == 1) {
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
fillcol = "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(max(K_i,3), palette)
fillcol = "white"
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
fillcol = "gray"
}  else {
stop('Invalid palette argument.')
}
} else {
stop('Invalid palette argument.')
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
K_i
i = 1
linecol = color[k]
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
results$scoresRecoded[,i]
table(theta, results$scoresRecoded[,i])
prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1)
apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
})
t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))
seq((K_i+1), 1, by = -1)
t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
t(apply(table(theta, results$scoresRecoded[,i]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
CPC.graph(SUP, itemOrder = 14:15)
CPC.graph(SUP, itemOrder = 14:15, observed = TRUE)
CPC.graph(SUP, itemOrder = 15, observed = TRUE)
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
K_i
apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))
apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
})
t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))
CPC.graph(SUP, itemOrder = 1, observed = TRUE)
CPC.graph(SUP, itemOrder = 2, observed = TRUE)
SUP$empties
SUP$itemInfo
CPC.graph(SUP, itemOrder = 12, observed = TRUE)
CPC.graph(SUP, itemOrder = 10, observed = TRUE)
CPC(SUP, observed = TRUE)
CPC.graph(SUP, observed = TRUE)
CPC.graph(SUP, itemOrder = 1)
itemInfo
K_i <- sum(!is.na(itemThres[i,]))
itemThres[i,]
results$itemThres
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
thres
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
theta
which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])
itemInfo$item.ID[i]
which(results$itemInfo$item.ID == itemInfo$item.ID[i]])
which(results$itemInfo$item.ID == itemInfo$item.ID[i]
)
devtools::load_all()
devtools::load_all()
CPC.graph(SUP, itemOrder = 1, observed = TRUE)
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])],
margin = 1), 1,
function(x) {
cumsum(rev(x))
})))[,seq((K_i + 1), 1, by = -1)]
apply(prop.table(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])],
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))
devtools::load_all()
CPC.graph(SUP, itemOrder = 1, observed = TRUE)
CPC.graph(SUP, itemOrder = NULL, observed = TRUE)
CPC.graph(SUP, itemOrder = 15, observed = TRUE)
devtools::build()
devtools::load_all()
?wm
?svg
?jpeg
devtools::load_all()
tutorial1 = craschR(SUPwide, itemInfo = SUPitem, consInfo = SUPcons,
estPackage = "TAM", writeout = TRUE)
names(tutorial1)
tutorial1$persPars
wm(tutorial1)
wm(tutorial1, writeout = TRUE, imageType = "png")
wm(tutorial1, writeout = TRUE, imageType = "pdf")
