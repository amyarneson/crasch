linecol = "black"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
}
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
}
thres
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
linecol
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = "black", lwd = 2)
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = "blue", lwd = 2)
linecol = color[k]
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = color[k], lwd = 2)
?curve
class(linecol)
?color
?as.color
?rgb
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = "#80B1D350", lwd = 2)
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = "#80B1D3", lwd = 2)
?curve
?function
?
?function
?
lines(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
linecol = color[k]
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
lines(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
}
?lines
y = boot::inv.logit(x - thres[k])
x = c(seq(from = -6, to = 6, length.out = 500))
y = boot::inv.logit(x - thres[k])
lines(x,y, col = linecol)
lines(x,y, col = "black")
lines(x,y, col = "black")
lines(x,y, col = linecol)
dev.off()
lines(x,y, col = linecol)
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
lines(x,y, col = linecol)
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
dev.off()
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(K_i, palette)
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
} else {
stop('palette must be "BASS", "grey", an RColorBrewer palette, or a character with 3 valid color specifications.')
}
if(writeout) {
eval(parse(text = paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")))
}
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(K_i, palette)
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
} else {
stop('palette must be "BASS", "grey", an RColorBrewer palette, or a character with 3 valid color specifications.')
}
if(writeout) {
eval(parse(text = paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")))
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 1:K_i) {
if (observed) {
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,i]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
} else {
linecol = "black"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
}
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
}
}
if (writeout) {
dev.off()
}
minCell = 8
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(K_i, palette)
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
} else {
stop('palette must be "BASS", "grey", an RColorBrewer palette, or a character with 3 valid color specifications.')
}
if(writeout) {
eval(parse(text = paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")))
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 1:K_i) {
if (observed) {
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,i]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
} else {
linecol = "black"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
}
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
}
}
if (writeout) {
dev.off()
}
observed = FALSE
for (i in 1:I) {
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(K_i, palette)
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
} else {
stop('palette must be "BASS", "grey", an RColorBrewer palette, or a character with 3 valid color specifications.')
}
if(writeout) {
eval(parse(text = paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")))
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 1:K_i) {
if (observed) {
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,i]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
} else {
linecol = "black"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
}
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
}
}
if (writeout) {
dev.off()
}
}
abline(v = theta, col = linecol, lty = 2, lwd = 2)
i = 1
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(K_i, palette)
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
} else {
stop('palette must be "BASS", "grey", an RColorBrewer palette, or a character with 3 valid color specifications.')
}
if(writeout) {
eval(parse(text = paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")))
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 1:K_i) {
if (observed) {
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,i]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
} else {
linecol = "black"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
}
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
}
}
focusTheta = c(-2,0,2)
abline(v = focusTheta, col = linecol, lty = 2, lwd = 2)
a = 1
bounds <- boot::inv.logit(focusTheta[a] - thres)
L <- placement <- rep(NA, length(bounds) + 1)
for (k in 0:K_i) {
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K) {
loBd = 0
} else {
loBd = bounds[k+1]
}
}
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K_i) {
loBd = 0
} else {
loBd = bounds[k+1]
}
upBd
loBd
L[k+1] = paste0("p(",k,")=", round(upBd - loBd, 2))
L
placement[k+1] = mean(c(upBd, loBd))
for (a in 1:length(focusTheta)) {
bounds <- boot::inv.logit(focusTheta[a] - thres)
L <- placement <- rep(NA, length(bounds) + 1)
for (k in 0:K_i) {
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K_i) {
loBd = 0
} else {
loBd = bounds[k+1]
}
L[k+1] = paste0("p(",k,")=", round(upBd - loBd, 2))
placement[k+1] = mean(c(upBd, loBd))
}
points(x = rep(focusTheta[a], length(bounds)), y = bounds, pch=21, bg = fillcol)
text(x=rep(theta[a],length(bounds)+1),y=placement,labels=L,pos=4,cex=.5)
}
fillcol = "#80b1d3"
for (a in 1:length(focusTheta)) {
bounds <- boot::inv.logit(focusTheta[a] - thres)
L <- placement <- rep(NA, length(bounds) + 1)
for (k in 0:K_i) {
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K_i) {
loBd = 0
} else {
loBd = bounds[k+1]
}
L[k+1] = paste0("p(",k,")=", round(upBd - loBd, 2))
placement[k+1] = mean(c(upBd, loBd))
}
points(x = rep(focusTheta[a], length(bounds)), y = bounds, pch=21,
bg = fillcol)
text(x = rep(focusTheta[a], length(bounds) + 1), y = placement,
labels = L, pos = 4, cex = .5)
}
devtools::document()
devtools::document()
devtools::load_all()
?CPC.graph
rm(list=ls())
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
CPC.graph(AMY)
CPC.graph(AMY, observed = TRUE, palette = "Set3")
devtools::load_all()
CPC.graph(AMY, observed = TRUE, palette = "Set3")
CPC.graph(AMY, observed = TRUE, palette = "PuBu")
devtools::load_all()
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
item.scores(AMY)
pers.hist(AMY)
wm(AMY)
wm(AMY, itemOrder = "construct")
ICC.graph(AMY)
CPC.graph(AMY)
CPC.graph(AMY, observed = TRUE, palette = "PuBu")
