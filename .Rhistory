devtools::load_all()
devtools::load_all()
GC_cons = read.csv("GC_cons (1).csv", stringsAsFactors = FALSE)
GC_item = read.csv("GC_item (1).csv", stringsAsFactors = FALSE)
GC_scores = read.csv("GC_wide (1).csv", row.names = 1, stringsAsFactors = FALSE)
#GC_vars = read.csv("GC_vars (1).csv", row.names = 1, stringsAsFactors = FALSE)
GC_analysis = craschR(scores = GC_scores, itemInfo = GC_item,
consInfo = GC_cons, writeout = TRUE)
wm(GC_analysis) # organized in item order
wm(GC_analysis, byCat = TRUE) # organized in construct category order
setwd("C:/Users/Amy/Desktop/Laura2")
library(crasch)
GC_cons = read.csv("GC_cons (1).csv", stringsAsFactors = FALSE)
GC_item = read.csv("GC_item (1).csv", stringsAsFactors = FALSE)
GC_scores = read.csv("GC_wide (1).csv", row.names = 1, stringsAsFactors = FALSE)
#GC_vars = read.csv("GC_vars (1).csv", row.names = 1, stringsAsFactors = FALSE)
GC_analysis = craschR(scores = GC_scores, itemInfo = GC_item,
consInfo = GC_cons, writeout = TRUE)
wm(GC_analysis) # organized in item order
wm(GC_analysis, byCat = TRUE) # organized in construct category order
library(crasch)
cons <- ADMcons[ADMcons$cons.ID %in% c(10001, 10002, 10003), ]
item <- ADMitem[ADMitem$cons.ID %in% cons$cons.ID, ]
item[item$item.ID %in% c(30037, 30038), c(7:9, 11, 14:15)] = TRUE
scores <- ADMlong[ADMlong$item.ID %in% item$item.ID, ]
rm(list = ls())
ADM3cons <- ADMcons[ADMcons$cons.ID %in% c(10001, 10002, 10003), ]
ADM3item <- ADMitem[ADMitem$cons.ID %in% ADM3cons$cons.ID, ]
ADM3item[ADM3item$item.ID %in% c(30037, 30038), c(7:9, 11, 14:15)] = TRUE
ADM3long <- ADMlong[ADMlong$item.ID %in% ADM3item$item.ID, ]
devtools::use_data(ADM3cons)
devtools::use_data(ADM3long)
devtools::use_data(ADM3item)
rm(list = ls())
ADM3analysis <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons,
longForm = TRUE, writeout = TRUE)
library(crasch)
devtools::load_all()
install.packages("testthat")
devtools::load_all()
ADM3analysis <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons,
longForm = TRUE, writeout = TRUE)
devtools::use_data(ADM3analysis)
pers.hist(ADM3analysis)
?pers.hist
KIDMAP(ADM3analysis, dim = 1)
KIDMAP(ADM3analysis, dim = 1, personID = 2)
View(ADM3analysis$scoresOrig)
KIDMAP(ADM3analysis, dim = 1, personID = 101)
?craschR
ADM3consecutive <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons, longForm = TRUE,
consecutive = TRUE, writeout = TRUE)
devtools::use_data(ADM3consecutive)
names(ADM3consecutive)
ADM3$estSummary
ADM3consecutive$estSummary
KIDMAP(ADM3consecutive, dim = 1, personID = 101)
pers.hist(ADM3consecutive, dim = 3)
pers.hist(ADM3analysis, dim = 3)
pers.hist(ADM3consecutive)
pers.hist(ADM3analysis)
KIDMAP(ADM3analysis, personID = 101, dim = 1)
devtools::load_all()
KIDMAP(ADM3analysis, personID = 101, dim = 1)
KIDMAP(ADM3consecutive, personID = 101, dim = 1)
KIDMAP(ADM3consecutive, personID =  101)
KIDMAP(ADM3consecutive, personID =  101)
devtools::load_all()
KIDMAP(ADM3consecutive, personID =  101)
devtools::load_all()
KIDMAP(ADM3consecutive, personID =  101)
?infit.MNSQ
infit.MNSQ(ADM3analysis)
infit.MNSQ(ADM3consecutive)
CPC.graph(ADM3analysis)
CPC.graph(ADM3consecutive)
ICC.graph(ADM3analysis)
ICC.graph(ADM3consecutive)
info.graph(ADM3analysis)
info.graph(ADM3consecutive)
wm(ADM3analysis)
wm(ADM3consecutive)
item.analysis(ADM3analysis)
item.analysis(ADM3consecutive)
results = ADM3analysis
checkResults(results)
checkWrite(writeout, fileSuffix)
byItem = cbind(Item_no = 1:results$estSummary$I,
Construct = results$consInfo$short.name[
match(results$itemInfo$cons.ID, results$consInfo$cons.ID)],
Count = colSums(!is.na(results$scoresRecoded)),
Missing = colSums(is.na(results$scoresRecoded)),
Estimate = results$itemPars[,1],
SE_est = results$itemSEs[,1],
results$itemFit[1:nrow(results$itemPars), c(2:4,6:8)]
)
View(byItem)
persProp = results$persRaw / results$persMax
View(persProp)
if (ncol(results$itemThres) > 1) {
K_total = sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)]))
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
start <- 1
for (i in 1:results$estSummary$I) {
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
}
} else if (ncol(results$itemThres) == 1) {
# create the byStep table (for dichotomous items)
K_total = 2 * results$estSummary$I
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
for(i in 1:results$estSummary$I) {
fill = c(2*i - 1, 2*i)
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
# item and category names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], 2)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], 2)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# there will be no empty categories (if there were, tam() would have failed)
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:1
# location estimates and standard errors
byStep$Estimate[fill[2]] = results$itemPars[i,1]
byStep$SE_est[fill[2]] = results$itemSEs[i,1]
# thresholds
byStep$Threshold[fill[2]] = results$itemThres[i]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
}
}
ncol(results$itemThres) > 1
K_total = sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)]))
colSums(results$itemInfo[,6:ncol(results$itemInfo)])
?colSums
K_total = sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)],
na.rm = TRUE))
devtools::load_all()
item.analysis(ADM3analysis)
item.analysis(ADM3consecutive)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
View(byStep)
start <- 1
1:results$estSummary$I
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
i = 1
for (i in 1:results$estSummary$I) {
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
}
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)])
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]),
na.rm = TRUE)
fill = c(start:(start + K_i - 1))
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
byStep$Count[fill] = table(results$scoresRecoded[,i])
byStep$Score[fill] = 0:(length(fill) - 1)
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]), cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
persProp[!is.na(results$scoresRecoded[,i]), cons]
!is.na(results$scoresRecoded[, i])
results$persRaw
results$persMax
results$scoresRecoded[, i]
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[, i]), cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[, i]), 1],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
if (!results$estSummary$consecutive & results$estSummary$D > 1) {
cons0 = 1
# non-consecutive multiD analysis should calc w/total score
} else {
cons0 = cons
# consecutive "multiD" analysis should calc w/subscore
}
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[, i]), cons0],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i] == byStep$Score[x])
})
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
View(ADM3analysis$persRaw)
View(ADM3consecutive$persRaw)
devtools::load_all()
ADM3analysis$persRaw
ADM3analysis <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons, longForm = TRUE, writeout = TRUE)
ADM3analysis$persRaw
ADM3analysis$persMax
devtools::use_data(ADM3analysis, overwrite = TRUE)
item.analysis(ADM3analysis)
devtools::check()
devtools::load_all()
item.analysis(ADM3analysis)
item.analysis(ADM3consecutive)
crasch::item.analysis(ADM3consecutive, writeout = TRUE)
ADM3consecutive <- craschR(scores = ADM3long, itemInfo = ADM3item,
consInfo = ADM3cons, longForm = TRUE,
consecutive = TRUE, writeout = TRUE)
devtools::load_all()
devtools::document()
devtools::load_all()
setwd("/Users/amy/Desktop/test")
results = ADM3consecutive
checkResults(results)
imageType = "png"
writeout = TRUE
checkWrite(writeout, fileSuffix)
checkImageType(imageType)
dim = NULL
normal = FALSE
fileSuffix = NULL
checkResults(results)
checkWrite(writeout, fileSuffix)
checkImageType(imageType)
checkDim(dim, results$consInfo)
origPar = par(no.readonly = TRUE) # to reset graphical parameters after
if (identical(palette, "BASS")) {
color <- c(bar = "#80b1d3", curve = "gray")
} else if (length(palette) == 1) {
if (palette %in% row.names(brewer.pal.info)) {
color <- RColorBrewer::brewer.pal(3, palette)
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette)) & length(palette)==2) {
color <- palette
} else {
stop('Invalid palette argument.')
}
palette = "BASS"
if (identical(palette, "BASS")) {
color <- c(bar = "#80b1d3", curve = "gray")
} else if (length(palette) == 1) {
if (palette %in% row.names(brewer.pal.info)) {
color <- RColorBrewer::brewer.pal(3, palette)
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette)) & length(palette)==2) {
color <- palette
} else {
stop('Invalid palette argument.')
}
layout(matrix(1))
par(mai=c(1.36, 1.093333, 1.093333, 0.56),
mar=c(5.1, 4.1, 4.1, 2.1))
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else {
D <- dim
}
d = 1
h <- hist(results$persPars[,d], plot = FALSE)
x <- seq(min(results$persPars[,d]), max(results$persPars[,d]), length = 200)
y <- dnorm(x, mean = results$popDist$mean[d],
sd = sqrt(results$popDist$var.cov[d,d])) * diff(h$mids[1:2]) *
nrow(results$persPars)
if (writeout) {
if (D==1) {
dd = NULL
} else {
dd = d
}
graphout = paste0("pershist", dd, fileSuffix, ".", imageType)
eval(parse(text=paste0(imageType,"('",graphout,"')")))
}
if (writeout) {
if (length(D) == 1) {
dd = NULL
} else {
dd = d
}
graphout = paste0("pershist", dd, fileSuffix, ".", imageType)
eval(parse(text=paste0(imageType,"('",graphout,"')")))
}
dev.off()
dev.off()
if (writeout) {
if (length(D) == 1) {
dd = NULL
} else {
dd = d
}
graphout = paste0("pershist", dd, fileSuffix, ".", imageType)
eval(parse(text = paste0(imageType, "('", graphout, "')")))
}
hist(results$persPars[,d], main = results$consInfo$short.name[d],
xlab = "Logits", col = color[1], freq = TRUE, axes = FALSE,
ylim = c(0, max(max(y), max(h$counts))))
axis(1, at = c(seq(0, min(0, floor(min(results$persPars[,d]))), by = -2),
seq(2, max(2, ceiling(max(results$persPars[,d]))), by = 2)))
axis(1, at = c(seq(-1, min(-1,floor(min(results$persPars[,d]))), by = -2),
seq(1, max(1, ceiling(max(results$persPars[,d]))), by = 2)),
labels = FALSE)
axis(2, las = 1)
Hmisc::minor.tick(nx = 1, ny = 2, tick.ratio = 1)
rm(x,y)
if (normal) {
x <- seq(min(results$persPars[,d]), max(results$persPars[,d]),
length = 200)
y <- dnorm(x, mean = results$popDist$mean[d],
sd = sqrt(results$popDist$var.cov[d,d])) * diff(h$mids[1:2]) *
nrow(results$persPars)
}
if (writeout) {
if (length(D) == 1) {
dd = NULL
} else {
dd = d
}
graphout = paste0("pershist", dd, fileSuffix, ".", imageType)
eval(parse(text = paste0(imageType, "('", graphout, "')")))
}
hist(results$persPars[,d], main = results$consInfo$short.name[d],
xlab = "Logits", col = color[1], freq = TRUE, axes = FALSE,
ylim = c(0, max(max(y), max(h$counts))))
axis(1, at = c(seq(0, min(0, floor(min(results$persPars[,d]))), by = -2),
seq(2, max(2, ceiling(max(results$persPars[,d]))), by = 2)))
axis(1, at = c(seq(-1, min(-1,floor(min(results$persPars[,d]))), by = -2),
seq(1, max(1, ceiling(max(results$persPars[,d]))), by = 2)),
labels = FALSE)
axis(2, las = 1)
Hmisc::minor.tick(nx = 1, ny = 2, tick.ratio = 1)
if (normal) {
lines(x, y, col = color[2], lty = 2, lwd = 2) # add normal curve
}
if (writeout) {
dev.off()
}
dev.off()
dev.off()
devtools::load_all()
devtools::load_all()
setwd("~/OneDrive/Development/crasch")
setwd("~/OneDrive/Development/crasch")
devtools::load_all()
pers.hist(ADM3analysis, writeout = TRUE)
h
devtools::load_all()
pers.hist(ADM3analysis, writeout = TRUE)
checkResults(results)
checkDim(dim, results$consInfo)
checkWrite(writeout, fileSuffix)
checkImageType(imageType)
par(mai=c(1.36,1.093333,1.093333,0.56),
mar=c(5.1,4.1,4.1,2.1),
xpd=FALSE)
tables <- list()
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else {
D <- dim
}
devtools::load_all()
item.scores(ADM3consecutive)
item.scores(ADM3consecutive)
dev.off()
dev.off()
item.scores(ADM3consecutive)
