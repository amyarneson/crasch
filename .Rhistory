mean(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
sdLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:ncol(itemInfo)])) - 1),
function(x) {
sd(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
j = j + 1
}
j <- 1
for (i in which(inclItems)) {
meanLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
mean(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
sdLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
sd(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
j = j + 1
}
View(itemInfo[, 6:(maxConsCat+5)])
View(itemInfo[inclItems, 6:(maxConsCat+5)])
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
itemXcat
sum(itemXcat*1)
meanLocs
sum(!is.na(meanLocs))
c(meanLocs)
itemXCat[itemXCat]*1
itemXcat[itemXcat]*1
itemXcat
itemXcat*1[itemXcat]
itemXcat*1
class(itemXcat*1)
meanLocs[!itemXcat]
?apply
?sapply
x = 1
returnVect <- rep(NA, length(x))
returnVect
fillIn <- c(meanLocs[x, ])
fillIn
fillIn = fillIn[!is.na(fillIn)]
fillIn
returnVect <- rep(NA, length(itemXcat[x,]))
returnVect
returnVect[itemXcat[x,]] = fillIn
itemXcat[x,]
returnVect[c(itemXcat[x,])]
returnVect[as.logical(itemXcat[x,])] = fillIn
returnVect
itemXcat
results$empties
meanLocs
row.names(meanLocs)[i]
row.names(meanLocs)[x]
results$itemInfo$item.name == row.names(meanLocs)[x]
which(results$itemInfo$item.name == row.names(meanLocs)[x])
results$empties[[which(results$itemInfo$item.name == row.names(meanLocs)[x])]]
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
length(itemEmpties)
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
if (length(itemEmpties) > 0) {
FILL[itemEmpties] = FALSE
}
returnVect[FILL] = fillIn
})
sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
if (length(itemEmpties) > 0) {
FILL[itemEmpties] = FALSE
}
returnVect[FILL] = fillIn
returnVect
})
sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
if (length(itemEmpties) > 0) {
FILL[itemEmpties] = FALSE
}
returnVect[FILL] = fillIn
t(returnVect)
})
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
if (length(itemEmpties) > 0) {
FILL[itemEmpties] = FALSE
}
returnVect[FILL] = fillIn
t(returnVect)
})
meanLocs = meanLocsByCat
meanLocsLong <- reshape(data.frame(meanLocs), varying = 1:ncol(meanLocs),
v.names = "X", direction = "long")
meanLocsLong = meanLocsLong[complete.cases(meanLocsLong), ]
meanLocsLong$score = meanLocsLong$time - 1
# figure out colors
if (length(palette) == 1) {
if (identical(palette, "BASS")) {
color <- "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(min(length(inclItems),
brewer.pal.info$maxcolors[which(row.names(brewer.pal.info) == palette)]),
palette)
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
interaction.plot(x.factor = meanLocsLong$score,
trace.factor = meanLocsLong$id,
response = meanLocsLong$X,
legend = FALSE, col = color, lty = 1, lwd = 2,
ylab = "Mean Location", xlab = "Numeric Score",
main = "Mean Location Trajectories by Item")
head(meanLocsLong)
View(meanLocsLong)
meanLocsLong <- reshape(data.frame(meanLocs), varying = 1:ncol(meanLocs),
v.names = "X", direction = "long")
View(meanLocsLong)
d
inclItems <- itemInfo$cons.ID == results$consInfo$cons.ID[d]
maxConsCat <- max(which(!is.na(results$consInfo[d,]))) - 3
meanLocs <- matrix(NA, nrow = sum(inclItems),
ncol = ncol(results$itemPars))
row.names(meanLocs) <- itemInfo$item.name[inclItems]
colnames(meanLocs) <- paste0("recodedScore", 0:(ncol(meanLocs) - 1))
sdLocs <- meanLocs
j <- 1
for (i in which(inclItems)) {
meanLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
mean(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
sdLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
sd(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
j = j + 1
}
meanLocs
meanLocsLong <- reshape(data.frame(meanLocs), varying = 1:ncol(meanLocs),
v.names = "X", direction = "long")
View(meanLocsLong)
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
if (length(itemEmpties) > 0) {
FILL[itemEmpties] = FALSE
}
returnVect[FILL] = fillIn
t(returnVect)
})
View(meanLocsByCat)
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
if (length(itemEmpties) > 0) {
FILL[itemEmpties] = FALSE
}
returnVect[FILL] = fillIn
returnVect
})
meanLocs = meanLocsByCat
meanLocsLong <- reshape(data.frame(meanLocs), varying = 1:ncol(meanLocs),
v.names = "X", direction = "long")
meanLocsLong = meanLocsLong[complete.cases(meanLocsLong), ]
meanLocsLong$score = meanLocsLong$time - 1
# figure out colors
if (length(palette) == 1) {
if (identical(palette, "BASS")) {
color <- "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(min(length(inclItems),
brewer.pal.info$maxcolors[which(row.names(brewer.pal.info) == palette)]),
palette)
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
interaction.plot(x.factor = meanLocsLong$score,
trace.factor = meanLocsLong$id,
response = meanLocsLong$X,
legend = FALSE, col = color, lty = 1, lwd = 2,
ylab = "Mean Location", xlab = "Numeric Score",
main = "Mean Location Trajectories by Item")
mtext(as.character(results$consInfo$short.name[d]))
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
if (length(itemEmpties) > 0) {
FILL[itemEmpties] = FALSE
}
returnVect[FILL] = fillIn
returnVect
})
x = 1
nrow(itemXcat)
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]]
which(results$itemInfo$item.name ==
row.names(meanLocs)[x])
itemEmpties <- which(results$itemInfo$item.name ==
row.names(meanLocs)[x])
itemEmpties
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- which(results$itemInfo$item.name ==
row.names(meanLocs)[x])
if (length(itemEmpties) > 0) {
FILL[results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]] ] = FALSE
}
returnVect[FILL] = fillIn
returnVect
})
x = 1
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- which(results$itemInfo$item.name ==
row.names(meanLocs)[x])
if (length(itemEmpties) > 0) {
FILL[results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]] ] = FALSE
}
returnVect[FILL] = fillIn
FILL
returnVect
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
fillIn
fillIn <- c(meanLocs[x, ])
fillIn
x = 1
meanLocs
inclItems <- itemInfo$cons.ID == results$consInfo$cons.ID[d]
maxConsCat <- max(which(!is.na(results$consInfo[d,]))) - 3
meanLocs <- matrix(NA, nrow = sum(inclItems),
ncol = ncol(results$itemPars))
row.names(meanLocs) <- itemInfo$item.name[inclItems]
colnames(meanLocs) <- paste0("recodedScore", 0:(ncol(meanLocs) - 1))
sdLocs <- meanLocs
j <- 1
for (i in which(inclItems)) {
meanLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
mean(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
sdLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
sd(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
j = j + 1
}
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- which(results$itemInfo$item.name ==
row.names(meanLocs)[x])
if (length(itemEmpties) > 0) {
FILL[results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]] ] = FALSE
}
returnVect[FILL] = fillIn
returnVect
})
meanLocsByCat
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- which(results$itemInfo$item.name ==
row.names(meanLocs)[x])
if (length(itemEmpties) > 0) {
FILL[results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]] ] = FALSE
}
returnVect[FILL] = fillIn
t(returnVect)
})
meanLocs = meanLocsByCat
meanLocsLong <- reshape(data.frame(meanLocs), varying = 1:ncol(meanLocs),
v.names = "X", direction = "long")
View(meanLocsLong)
meanLocsLong = meanLocsLong[complete.cases(meanLocsLong), ]
meanLocsLong$score = meanLocsLong$time - 1
# figure out colors
if (length(palette) == 1) {
if (identical(palette, "BASS")) {
color <- "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(min(length(inclItems),
brewer.pal.info$maxcolors[which(row.names(brewer.pal.info) == palette)]),
palette)
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
interaction.plot(x.factor = meanLocsLong$score,
trace.factor = meanLocsLong$id,
response = meanLocsLong$X,
legend = FALSE, col = color, lty = 1, lwd = 2,
ylab = "Mean Location", xlab = "Numeric Score",
main = "Mean Location Trajectories by Item")
inclItems <- itemInfo$cons.ID == results$consInfo$cons.ID[d]
maxConsCat <- max(which(!is.na(results$consInfo[d,]))) - 3
meanLocs <- matrix(NA, nrow = sum(inclItems),
ncol = ncol(results$itemPars))
row.names(meanLocs) <- itemInfo$item.name[inclItems]
colnames(meanLocs) <- paste0("recodedScore", 0:(ncol(meanLocs) - 1))
sdLocs <- meanLocs
j <- 1
for (i in which(inclItems)) {
meanLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
mean(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
sdLocs[j,] <- sapply(0:(sum(as.matrix(itemInfo[i, 6:(maxConsCat+5)])) - 1),
function(x) {
sd(results$persPars[scoresRecoded[, i] == x, d],
na.rm = TRUE)
})[1:ncol(meanLocs)]
j = j + 1
}
itemXcat <- itemInfo[inclItems,
stringr::str_detect(colnames(itemInfo),
'cat[0-9]')][, 1:maxConsCat]
meanLocsByCat <- sapply(1:nrow(itemXcat), function(x) {
fillIn <- c(meanLocs[x, ])
fillIn = fillIn[!is.na(fillIn)]
returnVect <- rep(NA, length(itemXcat[x,]))
FILL = as.logical(itemXcat[x,])
itemEmpties <- which(results$itemInfo$item.name ==
row.names(meanLocs)[x])
if (length(itemEmpties) > 0) {
FILL[results$empties[[which(results$itemInfo$item.name ==
row.names(meanLocs)[x])]] ] = FALSE
}
returnVect[FILL] = fillIn
returnVect
})
meanLocs = meanLocsByCat
meanLocsLong <- reshape(data.frame(meanLocs), varying = 1:ncol(meanLocs),
v.names = "X", direction = "long")
meanLocsLong = meanLocsLong[complete.cases(meanLocsLong), ]
meanLocsLong$score = meanLocsLong$time - 1
# figure out colors
if (length(palette) == 1) {
if (identical(palette, "BASS")) {
color <- "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(min(length(inclItems),
brewer.pal.info$maxcolors[which(row.names(brewer.pal.info) == palette)]),
palette)
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette))) {
color <- palette
} else {
stop('Invalid palette argument.')
}
interaction.plot(x.factor = meanLocsLong$score,
trace.factor = meanLocsLong$id,
response = meanLocsLong$X,
legend = FALSE, col = color, lty = 1, lwd = 2,
ylab = "Mean Location", xlab = "Numeric Score",
main = "Mean Location Trajectories by Item")
mtext(as.character(results$consInfo$short.name[d]))
View(meanLocsLong)
devtools::install_github("amyarneson/crasch")
library(WrightMap)
library(RColorBrewer)
setwd("C:/Users/arnes/OneDrive/Berkeley/DISSERTATION/02-CRESTA/empirical/consecutive")
consInfo <- read.csv("../CONS.csv", stringsAsFactors = FALSE)
itemInfo <- read.csv("../ITEM.csv", stringsAsFactors = FALSE)
scores <- read.csv("../WIDESCORES.csv", stringsAsFactors = FALSE, row.names = 1)
demogs <- read.csv("../DEMOGS.csv", stringsAsFactors = FALSE)
# remove problematic respondents
scores = scores[demogs$REMOVE == 0, ] #same order in both files!
demogs = demogs[demogs$REMOVE == 0, ]
demogs$Username == row.names(scores)
# whole sample demographics
prop.table(table(demogs$Grade, useNA = "ifany"))
prop.table(table(demogs$Gender, useNA = "ifany"))
prop.table(table(demogs$Race, useNA = "ifany"))
prop.table(table(demogs$APorIBmath, useNA = "ifany"))
prop.table(table(demogs$StatProbCoursework, useNA = "ifany"))
trimObjects <- function(FullScores, FullItemInfo, FullConsInfo, ConsID) {
consInfo0 <- FullConsInfo[FullConsInfo$cons.ID %in% ConsID, ]
if (any(is.na(consInfo0))) {
consInfo0 = consInfo0[, 1:max(which(!is.na(consInfo0)))]
}
itemInfo0 <- FullItemInfo[FullItemInfo$cons.ID %in% ConsID, ]
itemInfo0 = itemInfo0[, 1:(ncol(consInfo0)+2)]
scores0 <- FullScores[, FullItemInfo$cons.ID %in% ConsID]
#already checked for same order
keepRows <- rowSums(!is.na(scores0)) > 4
scores0 = scores0[keepRows, ]
return(list(
scores = scores0,
consInfo = consInfo0,
itemInfo = itemInfo0
))
}
# LDC analysis
LDCobj <- trimObjects(scores, itemInfo, consInfo, 10)
LDCresults <- crasch::craschR(LDCobj$scores, LDCobj$itemInfo, LDCobj$consInfo,
retainOrig = TRUE, writeout = FALSE)
# LDC analysis
LDCobj <- trimObjects(scores, itemInfo, consInfo, 10)
LDCresults <- crasch::craschR(LDCobj$scores, LDCobj$itemInfo, LDCobj$consInfo,
retainOrig = TRUE, writeout = FALSE)
