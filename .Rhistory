itemThres[i,]
results$itemThres
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
thres
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
theta
which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])
itemInfo$item.ID[i]
which(results$itemInfo$item.ID == itemInfo$item.ID[i]])
which(results$itemInfo$item.ID == itemInfo$item.ID[i]
)
devtools::load_all()
devtools::load_all()
CPC.graph(SUP, itemOrder = 1, observed = TRUE)
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])],
margin = 1), 1,
function(x) {
cumsum(rev(x))
})))[,seq((K_i + 1), 1, by = -1)]
apply(prop.table(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])],
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))
devtools::load_all()
CPC.graph(SUP, itemOrder = 1, observed = TRUE)
CPC.graph(SUP, itemOrder = NULL, observed = TRUE)
CPC.graph(SUP, itemOrder = 15, observed = TRUE)
devtools::build()
devtools::load_all()
?wm
?svg
?jpeg
devtools::load_all()
tutorial1 = craschR(SUPwide, itemInfo = SUPitem, consInfo = SUPcons,
estPackage = "TAM", writeout = TRUE)
names(tutorial1)
tutorial1$persPars
wm(tutorial1)
wm(tutorial1, writeout = TRUE, imageType = "png")
wm(tutorial1, writeout = TRUE, imageType = "pdf")
devtools::load_all()
?KIDMAP
KIDMAP(ADP, 101)
names(ADP)
head(ADP$persPars)
KIDMAP(ADP, 110)
KIDMAP(ADP, c(110, 111))
results = ADP
personID = c(110:113)
dim = NULL
probBounds = c(.25, .75)
palette = "BASS"
writeout = FALSE
(!(all(as.character(personID) %in% row.names(results$scoresOrig)) &
(is.character(personID) | is.numeric(personID))))
personID
personID <- 100:110
(!(all(as.character(personID) %in% row.names(results$scoresOrig)) &
(is.character(personID) | is.numeric(personID))))
(all(as.character(personID) %in% row.names(results$scoresOrig))
)
(is.character(personID) | is.numeric(personID))
personID = c(110:113)
rowIndex <- which(row.names(results$scoresRecoded) == as.character(personID))
row.names(results$scoresRecoded)
as.character(personID)
which(row.names(results$scoresRecoded) %in% as.character(personID))
rowIndex <- which(row.names(results$scoresRecoded) %in% as.character(personID))
respVector <- as.numeric(results$scoresRecoded[rowIndex,])
results$scoresRecoded[rowIndex,]
i = 1
respVector <- as.numeric(results$scoresRecoded[i,])
respVector
inclItem <- which(results$itemInfo$cons.ID == results$consInfo$cons.ID[d])
thres <- results$itemThres[inclItem,]
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else if (is.numeric(dim)) {
D <- dim
} else {
stop('Invalid dim argument.')
}
inclItem <- which(results$itemInfo$cons.ID == results$consInfo$cons.ID[d])
thres <- results$itemThres[inclItem,]
D
d = 1
inclItem <- which(results$itemInfo$cons.ID == results$consInfo$cons.ID[d])
thres <- results$itemThres[inclItem,]
respVector <- as.numeric(results$scoresRecoded[i,])
toPlot <- data.frame(x = rep(1, prod(dim(thres))),
thres = c(t(thres)),
step = rep(1:ncol(thres), length(inclItem)),
score = rep(respVector[inclItem], each = ncol(thres)) )
rep(1:ncol(thres), length(inclItem)), sep = "_")
row.names(toPlot) <- paste(rep(row.names(thres), each = ncol(thres)),
rep(1:ncol(thres), length(inclItem)), sep = "_")
toPlot = toPlot[complete.cases(toPlot),] # removes steps that don't exist
# AND skipped items
toPlot$x[toPlot$step <= toPlot$score] = -1
loBd = results$persPars[rowIndex, d] - log(probBounds[2] / (1 - probBounds[2]))
paste0(imageType, "('KIDMAP-", i, "_", d, fileSuffix,
".", imageType, "')")
imageType = "pdf"
paste0(imageType, "('KIDMAP-", i, "_", d, fileSuffix,
".", imageType, "')")
fileSuffix = NULL
paste0(imageType, "('KIDMAP-", i, "_", d, fileSuffix,
".", imageType, "')")
results$consInfo$short.name[d]
paste0(imageType, "('KIDMAP-", i, "_",
results$consInfo$short.name[d], fileSuffix,
".", imageType, "')")
devtools::load_all()
KIDMAP(ADP, 110)
KIDMAP(ADP, 110:113)
rm(rowIndex)
devtools::load_all()
KIDMAP(ADP, 110:113)
devtools::build()
?CPC.graph
CPC.graph(ADP, itemOrder = c(1:4))
CPC.graph(ADP, itemOrder = c(1:4), observed = TRUE)
CPC.graph(ADP, itemOrder = c(1:4), observed = TRUE, min.cell = 2)
CPC.graph(ADP, itemOrder = c(1:4), observed = TRUE, minCell = 2)
devtools::load_all()
CPC.graph(ADP, itemOrder = c(1:4), observed = TRUE, minCell = 2)
CPC.graph(ADP, observed = TRUE, minCell = 2)
results
itemOrder = NULL
palette = "BASS"
observed = FALSE
minCell = 2
focusTheta = c(-2,0,2)
logitAxis = "x"
writeout = FALSE
imageType = "pdf"
fileSuffix = NULL
checkResults(results)
checkWrite(writeout, fileSuffix)
checkImageType(imageType)
checkItemOrder(itemOrder, results$itemInfo)
if (!is.logical(observed)) {
stop('Invalid observed argument.')
}
if (!(is.numeric(minCell) & (minCell > 0) & (minCell %% 1 == 0))) {
stop('Invalid minCell argument.')
}
if (!is.numeric(focusTheta)) {
stop('Invalid focusTheta argument.')
}
if (minCell < 10 & observed) {
warning('Low cell counts (<10) will be graphed. Interpret with caution.')
}
origPar = par(no.readonly = TRUE) # to reset graphical parameters after
par(xpd = FALSE)
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
if (length(itemOrder) == 1) {
itemThres <- matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(results$itemThres)))
} else {
itemThres <- results$itemThres[itemOrder,]
}
} else {
stop('itemOrder must be a numeric vector or NULL.')
}
I <- nrow(itemInfo)
I
i = 1
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (length(palette) == 1) {
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
fillcol = "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(max(K_i,3), palette)
fillcol = "white"
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
fillcol = "gray"
}  else {
stop('Invalid palette argument.')
}
} else {
stop('Invalid palette argument.')
}
paste0(imageType, "('ICC", itemInfo$item.ID[i],
fileSuffix, ".", imageType, "')")
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
if (logitAxis == "x") {
xlim = c(-6, 6)
ylim = c(0, 1)
xlab = "Logits"
ylab = "Probability"
logits = 1
probability = 2
} else {
ylim = c(-6, 6)
xlim = c(0, 1)
ylab = "Logits"
xlab = "Probability"
logits = 2
probability = 1
}
plot(1, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab,
axes = FALSE, main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(logits, at = seq(-6, 6, 2))
axis(logits, at = seq(-5, 5, 2), labels = FALSE)
axis(probability, at = seq(0, 1, .2), las = 1)
axis(probability, at = seq(.1, .9, .2), labels = FALSE)
logitAxis == "y"
logitAxis = "y"
if (logitAxis == "x") {
xlim = c(-6, 6)
ylim = c(0, 1)
xlab = "Logits"
ylab = "Probability"
logits = 1
probability = 2
} else {
ylim = c(-6, 6)
xlim = c(0, 1)
ylab = "Logits"
xlab = "Probability"
logits = 2
probability = 1
}
plot(1, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab,
axes = FALSE, main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(logits, at = seq(-6, 6, 2))
axis(logits, at = seq(-5, 5, 2), labels = FALSE)
axis(probability, at = seq(0, 1, .2), las = 1)
axis(probability, at = seq(.1, .9, .2), labels = FALSE)
1:K_i
k = 1
linecol = "black"
vlinecol = "grey"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
if (logitAxis == "x") {
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
} else {
polygon(c(y1, rev(y2)), c(x, rev(x)), col = color[k], border = NA)
}
?boot::inv.logit
}
if (logitAxis == "x") {
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
} else {
curve(log(x / (1 - x)) + thres[k], from = 0, to = 1, add = TRUE,
col = linecol, lwd = 2)
}
x = sort(unique(theta))[cellCts[,(k+1)] >= minCell]
y = empPts[cellCts[,(k+1)] >= minCell,(k+1)]
if (logitAxis == "x") {
points(x, y, col = color[k], pch = 20)
lines(x, y, col = color[k], lwd = 2, lty = 2)
} else {
points(y, x, col = color[k], pch = 20)
lines(y, x, col = color[k], lwd = 2, lty = 2)
}
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
checkResults(results)
checkWrite(writeout, fileSuffix)
checkImageType(imageType)
checkItemOrder(itemOrder, results$itemInfo)
if (!is.logical(observed)) {
stop('Invalid observed argument.')
}
if (!(is.numeric(minCell) & (minCell > 0) & (minCell %% 1 == 0))) {
stop('Invalid minCell argument.')
}
if (!is.numeric(focusTheta)) {
stop('Invalid focusTheta argument.')
}
if (minCell < 10 & observed) {
warning('Low cell counts (<10) will be graphed. Interpret with caution.')
}
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
if (length(itemOrder) == 1) {
itemThres <- matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(results$itemThres)))
} else {
itemThres <- results$itemThres[itemOrder,]
}
} else {
stop('itemOrder must be a numeric vector or NULL.')
}
I <- nrow(itemInfo)
i = 1
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (length(palette) == 1) {
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
fillcol = "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(max(K_i,3), palette)
fillcol = "white"
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
fillcol = "gray"
}  else {
stop('Invalid palette argument.')
}
} else {
stop('Invalid palette argument.')
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
if (logitAxis == "x") {
xlim = c(-6, 6)
ylim = c(0, 1)
xlab = "Logits"
ylab = "Probability"
logits = 1
probability = 2
} else {
ylim = c(-6, 6)
xlim = c(0, 1)
ylab = "Logits"
xlab = "Probability"
logits = 2
probability = 1
}
plot(1, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab,
axes = FALSE, main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(logits, at = seq(-6, 6, 2))
axis(logits, at = seq(-5, 5, 2), labels = FALSE)
axis(probability, at = seq(0, 1, .2), las = 1)
axis(probability, at = seq(.1, .9, .2), labels = FALSE)
k = 1
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
if (logitAxis == "x") {
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
} else {
curve(log(x / (1 - x)) + thres[k], from = 0, to = 1, add = TRUE,
col = linecol, lwd = 2)
}
x = sort(unique(theta))[cellCts[,(k+1)] >= minCell]
y = empPts[cellCts[,(k+1)] >= minCell,(k+1)]
if (logitAxis == "x") {
points(x, y, col = color[k], pch = 20)
lines(x, y, col = color[k], lwd = 2, lty = 2)
} else {
points(y, x, col = color[k], pch = 20)
lines(y, x, col = color[k], lwd = 2, lty = 2)
}
plot(1, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab,
axes = FALSE, main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(logits, at = seq(-6, 6, 2))
axis(logits, at = seq(-5, 5, 2), labels = FALSE)
axis(probability, at = seq(0, 1, .2), las = 1)
axis(probability, at = seq(.1, .9, .2), labels = FALSE)
linecol = "black"
vlinecol = "grey"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
if (logitAxis == "x") {
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
} else {
polygon(c(y1, rev(y2)), c(x, rev(x)), col = color[k], border = NA)
}
if (logitAxis == "x") {
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
} else {
curve(log(x / (1 - x)) + thres[k], from = 0, to = 1, add = TRUE,
col = linecol, lwd = 2)
}
if (logitAxis == "x") {
abline(v = focusTheta, col = vlinecol, lty = 2, lwd = 2)
} else {
abline(h = focusTheta, col = vlinecol, lty = 2, lwd = 2)
}
for (a in 1:length(focusTheta)) {
bounds <- boot::inv.logit(focusTheta[a] - thres)
L <- placement <- rep(NA, length(bounds) + 1)
for (k in 0:K_i) {
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K_i) {
loBd = 0
} else {
loBd = bounds[k+1]
}
L[k+1] = paste0("p(",k,")=", round(upBd - loBd, 2))
placement[k+1] = mean(c(upBd, loBd))
}
x1 = rep(focusTheta[a], length(bounds))
x2 = rep(focusTheta[a], length(bounds) + 1)
if (logitAxis == "x") {
points(x1, bounds, pch=21, bg = fillcol)
text(x2, placement, labels = L, pos = 4, cex = .5)
} else {
points(bounds, x1, pch=21, bg = fillcol)
text(placement, x2, labels = L, pos = 4, cex = .5)
}
}
devtools::load_all()
CPC.graph(ADP, itemOrder = 1)
CPC.graph(ADP, itemOrder = 1, observed = TRUE)
CPC.graph(ADP, itemOrder = 2)
CPC.graph(ADP, itemOrder = 2, observed = TRUE)
CPC.graph(ADP, itemOrder = 3, observed = TRUE)
CPC.graph(ADP, itemOrder = 4, observed = TRUE)
CPC.graph(ADP, itemOrder = 5, observed = TRUE)
CPC.graph(ADP, itemOrder = 6, observed = TRUE)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2, logitAxis = "y")
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y")
devtools::load_all
devtools::load_all()
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y")
devtools::load_all()
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y")
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y", focusTheta = 0)
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "x", focusTheta = 0)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2, logitAxis = "x", focusTheta = 0)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2, logitAxis = "y", focusTheta = 0)
if (length(logitAxis) != 1) {
stop('Invalid logitAxis argument.')
} else {
if (logitAxis == "x") {
logitX = TRUE
} else if (logitAxis == "y") {
logitX = FALSE
} else {
stop('Invalid logitAxis argument.')
}
}
devtools::load_all()
devtools::build()
devtools::document()
devtools::build()
devtools::load_all()
?data.frame
devtools::load_all()
?craschR
craschR(SUPwide, SUPitem, SUPcons)
SUP<- craschR(SUPwide, SUPitem, SUPcons)
SUP$persFit
devtools::build()
