fill = c(start:(start + K_i - 1))
fill
byStep[fill,1] = rep(results$itemInfo$item.name[i], K_i)
byStep[fill,2] = rep(results$consInfo$short.name[cons], K_i)
byStep[fill,3] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
head(byStep)
length(results$empties[[i]]) > 0
byStep[fill,4] = table(results$scoresRecoded[,i])
head(byStep)
results$itemPars[i,2:(length(fill))]
results$itemSEs[i,2:(length(fill))]
results$itemThres
results$itemPars[i,1:(length(fill) - 1)]
results$itemThres[i,1:(length(fill) - 1)]
names(results)
head(results$persFit)
head(results$persPars)
names(results)
results$persPars
devtools::load_all()
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
names(AMY)
results = AMY
results$persRaw
persProp = results$persRaw / results$persMax
persProp
pers.rawprop[!is.na(results$scoresRecoded[,i])
]
persProp[!is.na(results$scoresRecoded[,i])]
?ltm::biserial.cor
results$scoresRecoded[,i]
!is.na(results$scoresRecoded[,i])
persProp[!is.na(results$scoresRecoded[,i]),cons]
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep[1,5]
byStep[fill,5] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep[fill[-1],6] = results$itemPars[i,2:(length(fill))]
byStep[fill[-c(1,length(fill))],7] = results$itemSEs[i,2:(length(fill))]
# thresholds
byStep[fill[-1],8] = results$itemThres[i,1:(length(fill) - 1)]
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep[1,5]
sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep[x,5])
})
results$itemSEs[i,2:(length(fill))]
fill[-c(1,length(fill))]
byStep[fill[-c(1,length(fill))],7] = results$itemSEs[i,2:(length(fill) - 1)]
head(byStep)
byStep[fill,9] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep[x,5])
})
head(byStep)
class(byStep[,1])
class(byStep[,9])
byStep = matrix(nrow = sum(!is.na(results$itemThres)) +
results$estSummary$I, ncol = 11)
class(byStep[,9])
colnames(byStep) = c("Item", "Construct", "Cat", "Count", "Score",
"Estimate", "SE_est", "Threshold", "PtBiserial",
"MeanAbil", "SD_MeanAbil")
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
byStep[fill,1] = rep(results$itemInfo$item.name[i], K_i)
byStep[fill,2] = rep(results$consInfo$short.name[cons], K_i)
byStep[fill,3] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
class(byStep[,9])
byStep = matrix(nrow = sum(!is.na(results$itemThres)) +
results$estSummary$I, ncol = 11)
colnames(byStep) = c("Item", "Construct", "Cat", "Count", "Score",
"Estimate", "SE_est", "Threshold", "PtBiserial",
"MeanAbil", "SD_MeanAbil")
class(byStep[,9])
byStep[fill,1] = rep(results$itemInfo$item.name[i], K_i)
class(byStep[,9])
byStep[fill,2] = rep(results$consInfo$short.name[cons], K_i)
byStep[fill,3] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep[fill,3] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep[fill,3] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep[fill,4] = as.numeric(table(results$scoresRecoded[,i]))
head(byStep)
byStep = data.frame(nrow = sum(!is.na(results$itemThres)) +
results$estSummary$I, ncol = 11)
colnames(byStep) = c("Item", "Construct", "Cat", "Count", "Score",
"Estimate", "SE_est", "Threshold", "PtBiserial",
"MeanAbil", "SD_MeanAbil")
View(byStep)
?vector
byStep = data.frame(Item = vector(mode = "character",
length = sum(!is.na(results$itemThres)) +
results$estSummary$I),
Construct = vector(mode = "character"),
Cat = vector(mode = "character"),
Count = vector(mode = "numeric"),
Score = vector(mode = "numeric"),
Estimate = vector(mode = "numeric"),
SE_est = vector(mode = "numeric"),
Threshold = vector(mode = "numeric"),
PtBiserial = vector(mode = "numeric"),
MeanAbil = vector(mode = "numeric"),
SD_MeanAbil = vector(mode = "numeric"))
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = vector(mode = "numeric", length = K_total),
Score = vector(mode = "numeric", length = K_total),
Estimate = vector(mode = "numeric", length = K_total),
SE_est = vector(mode = "numeric", length = K_total),
Threshold = vector(mode = "numeric", length = K_total),
PtBiserial = vector(mode = "numeric", length = K_total),
MeanAbil = vector(mode = "numeric", length = K_total),
SD_MeanAbil = vector(mode = "numeric", length = K_total))
K_total = sum(!is.na(results$itemThres)) + results$estSummary$I
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = vector(mode = "numeric", length = K_total),
Score = vector(mode = "numeric", length = K_total),
Estimate = vector(mode = "numeric", length = K_total),
SE_est = vector(mode = "numeric", length = K_total),
Threshold = vector(mode = "numeric", length = K_total),
PtBiserial = vector(mode = "numeric", length = K_total),
MeanAbil = vector(mode = "numeric", length = K_total),
SD_MeanAbil = vector(mode = "numeric", length = K_total))
View(byStep)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = vector(mode = "logical", length = K_total),
Score = vector(mode = "logical", length = K_total),
Estimate = vector(mode = "logical", length = K_total),
SE_est = vector(mode = "logical", length = K_total),
Threshold = vector(mode = "logical", length = K_total),
PtBiserial = vector(mode = "logical", length = K_total),
MeanAbil = vector(mode = "logical", length = K_total),
SD_MeanAbil = vector(mode = "logical", length = K_total))
View(byStep)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = as.vector(rep(NA, K_total), mode = "character"),
Count = vector(mode = "logical", length = K_total),
Score = vector(mode = "logical", length = K_total),
Estimate = vector(mode = "logical", length = K_total),
SE_est = vector(mode = "logical", length = K_total),
Threshold = vector(mode = "logical", length = K_total),
PtBiserial = vector(mode = "logical", length = K_total),
MeanAbil = vector(mode = "logical", length = K_total),
SD_MeanAbil = vector(mode = "logical", length = K_total))
View(byStep)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = as.vector(rep(NA, K_total), mode = "numeric"),
Count = vector(mode = "logical", length = K_total),
Score = vector(mode = "logical", length = K_total),
Estimate = vector(mode = "logical", length = K_total),
SE_est = vector(mode = "logical", length = K_total),
Threshold = vector(mode = "logical", length = K_total),
PtBiserial = vector(mode = "logical", length = K_total),
MeanAbil = vector(mode = "logical", length = K_total),
SD_MeanAbil = vector(mode = "logical", length = K_total))
View(byStep)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanAbil = as.vector(rep(NA, K_total), mode = "numeric"),
SD_MeanAbil = as.vector(rep(NA, K_total), mode = "numeric"))
View(byStep)
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
View(byStep)
byStep$Count[fill] = table(results$scoresRecoded[,i])
View(byStep)
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep[x,5])
})
View(byStep)
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
byStep = data.frame(Item = vector(mode = "any", length = K_total),
Construct = vector(mode = "any", length = K_total),
Cat = vector(mode = "any", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanAbil = as.vector(rep(NA, K_total), mode = "numeric"),
SD_MeanAbil = as.vector(rep(NA, K_total), mode = "numeric"))
class(results$itemInfo$item.name)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanAbil = as.vector(rep(NA, K_total), mode = "numeric"),
SD_MeanAbil = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
View(byStep)
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
View(byStep)
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
sapply(fill,function(x){
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
K_total = sum(!is.na(results$itemThres)) + results$estSummary$I
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
start <- 1
for (i in 1:results$estSummary$I) {
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x){
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
}
View(byStep)
byItem = cbind(Item_no = 1:nrow(results$estSummary$I),
Construct = results$consInfo$short.name[
match(results$itemInfo$cons.ID, results$consInfo$cons.ID)],
Count = colSums(!is.na(results$scoresRecoded)),
Missing = colSums(is.na(results$scoresRecoded)),
Estimate = results$itemPars[,1],
SE_est = results$itemSEs[,1],
results$itemFit[1:nrow(results$itemPars), c(2:4,6:8)]
)
#persProp table needed for point biserials
persProp = results$persRaw / results$persMax
#byStep table for PCM
if (ncol(results$itemThres) > 1) {
K_total = sum(!is.na(results$itemThres)) + results$estSummary$I
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
start <- 1
for (i in 1:results$estSummary$I) {
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
}
}
results$empties
c(results$empties)
as.vector(results$empties)
paste(results$empties, collapse = "")
results$itemInfo
sum(results$itemInfo[,6:ncol(results$itemInfo)])
sum(as.logical(results$itemInfo[,6:ncol(results$itemInfo)]))
class(results$itemInfo$cat1)
sum(matrix(results$itemInfo[,6:ncol(results$itemInfo)]))
results$itemInfo[,6:ncol(results$itemInfo)]
c(results$itemInfo[,6:ncol(results$itemInfo)])
sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)]))
K_total = sum(colSums(results$itemInfo[,6:ncol(results$itemInfo)]))
byStep = data.frame(Item = vector(mode = "character", length = K_total),
Construct = vector(mode = "character", length = K_total),
Cat = vector(mode = "character", length = K_total),
Count = as.vector(rep(NA, K_total), mode = "numeric"),
Score = as.vector(rep(NA, K_total), mode = "numeric"),
Estimate = as.vector(rep(NA, K_total), mode = "numeric"),
SE_est = as.vector(rep(NA, K_total), mode = "numeric"),
Threshold = as.vector(rep(NA, K_total), mode = "numeric"),
PtBiserial = as.vector(rep(NA, K_total), mode = "numeric"),
MeanPersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
SD_PersLoc = as.vector(rep(NA, K_total), mode = "numeric"),
stringsAsFactors = FALSE)
start <- 1
for (i in 1:results$estSummary$I) {
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
}
View(byStep)
devtools::load_all()
devtools::load_all()
devtools::load_all()
item.analysis(AMY)
rm(cons,fill,i,K_i,K_total,start,persProp,byItem,byStep)
byItem = cbind(Item_no = 1:nrow(results$estSummary$I),
Construct = results$consInfo$short.name[
match(results$itemInfo$cons.ID, results$consInfo$cons.ID)],
Count = colSums(!is.na(results$scoresRecoded)),
Missing = colSums(is.na(results$scoresRecoded)),
Estimate = results$itemPars[,1],
SE_est = results$itemSEs[,1],
results$itemFit[1:nrow(results$itemPars), c(2:4,6:8)]
)
names(results)
results$estSummary$I
devtools::load_all()
item.analysis(AMY)
item.analysis(AMY,writeout=TRUE)
