col = color[2], border = NA)
rect(xleft = 0, xright = 1.5, ybottom = -100, ytop = loBd,
col = color[2], border = NA)
abline(v = 0)
abline(h = results$persPars[rowIndex, d])
axis(side = 2, at = c(seq(0, floor(min(toPlot$thres, loBd) - .2), by = -1),
seq(0, ceiling(max(toPlot$thres, upBd) + .2), by = 1)),
las = 1)
axis(side = 4, at = c(seq(0, floor(min(toPlot$thres, loBd) - .2), by = -1),
seq(0, ceiling(max(toPlot$thres, upBd) + .2), by = 1)),
las = 1)
points(x = toPlot$x, y = toPlot$thres, pch = 21, bg = color[3])
if (sum(toPlot$x == -1) == 1) {
text(x = -1, y = toPlot$thres[toPlot$x == -1],
row.names(toPlot[toPlot$x == -1,]), pos = 4, cex = .5)
}
if (sum(toPlot$x == 1) == 1) {
text(x = 1, y = toPlot$thres[toPlot$x == 1],
row.names(toPlot[toPlot$x == 1,]), pos = 2, cex = .5)
}
toPlot$thres[toPlot$x == -1]
sort(toPlot$thres[toPlot$x == -1])[seq(1, sum(toPlot$x == -1), 2)]
sort(toPlot$thres[toPlot$x == -1])
lft.R = sort(toPlot$thres[toPlot$x == -1])[seq(2, sum(toPlot$x == -1), 2)]
sort(toPlot$thres[toPlot$x == -1])[seq(2, sum(toPlot$x == -1), 2)]
toPlot
class(toPlot)
toPlot$thres[toPlot$x == -1]
order(toPlot$x)
order(toPlot$thres)
rm(lft.L, lft.R)
row.names(toPlot)[order(toPlot$thres)
])
row.names(toPlot)[order(toPlot$thres)]
text(-1, sort(toPlot$thres), labels = row.names(toPlot)[order(toPlot$thres)],
pos = c(2, 4), cex = .5)
plot(1, type = "n", xlim = c(-1.5, 1.5),
ylim = c(min(toPlot$thres, loBd) - .2, max(toPlot$thres, upBd) + .2),
axes = FALSE, xlab = "", ylab = "Logits", main = "KIDMAP")
mtext(paste0("Person: ", personID,
"\nEst Theta: ", round(results$persPars[rowIndex, d], 2)),
side = 3, line = 0, cex = .8)
mtext(paste0("Raw: ", round(results$persRaw[rowIndex, d], 2), "/",
round(results$persMax[rowIndex, d], 2),
"\nOutfit: ", round(results$persFit[[d]]$outfit[rowIndex], 2),
" (t=",round(results$persFit[[d]]$outfit_t[rowIndex], 2), ")",
"\nInfit: ", round(results$persFit[[d]]$infit[rowIndex], 2),
" (t=",round(results$persFit[[d]]$infit_t[rowIndex], 2), ")"),
side = 1, line = 2, cex = .7)
mtext("Reached", adj = 0)
mtext("Not Reached", adj = 1)
rect(xleft = -1.5, xright = 1.5, ybottom = loBd, ytop = upBd,
col = color[1], border = NA)
rect(xleft = -1.5, xright = 0, ybottom = upBd, ytop = 100,
col = color[2], border = NA)
rect(xleft = 0, xright = 1.5, ybottom = -100, ytop = loBd,
col = color[2], border = NA)
abline(v = 0)
abline(h = results$persPars[rowIndex, d])
axis(side = 2, at = c(seq(0, floor(min(toPlot$thres, loBd) - .2), by = -1),
seq(0, ceiling(max(toPlot$thres, upBd) + .2), by = 1)),
las = 1)
axis(side = 4, at = c(seq(0, floor(min(toPlot$thres, loBd) - .2), by = -1),
seq(0, ceiling(max(toPlot$thres, upBd) + .2), by = 1)),
las = 1)
points(x = toPlot$x, y = toPlot$thres, pch = 21, bg = color[3])
if (sum(toPlot$x == -1) == 1) {
text(x = -1, y = toPlot$thres[toPlot$x == -1],
row.names(toPlot[toPlot$x == -1,]), pos = 4, cex = .5)
} else if (sum(toPlot$x == -1) > 1) {
text(-1, sort(toPlot$thres[toPlot$x == -1]),
labels = row.names(toPlot)[order(toPlot$thres)[toPlot$x == -1]],
pos = c(2, 4), cex = .5)
}
text(x = 1, y = sort(toPlot$thres[toPlot$x == 1]),
labels = row.names(toPlot)[order(toPlot$thres)[toPlot$x == 1]],
pos = c(2, 4), cex = .5)
devtools::load_all()
rm(list=ls())
load("C:/Users/Amy/OneDrive/Development/crasch/.RData")
KIDMAP(AMY, personID = 131)
KIDMAP(AMY, personID = "131")
rm(AMY)
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
save.image("C:/Users/Amy/OneDrive/Development/crasch/.RData")
KIDMAP(AMY, personID = 131)
KIDMAP(AMY, personID = "131")
KIDMAP(AMY, personID = 131)
KIDMAP(AMY, personID = "131")
KIDMAP(AMY, personID = 131)
KIDMAP(AMY, personID = "131")
as.character)(131)
as.character(131)
as.character("131")
AMY$persFit
devtools::load_all()
results = AMY
dim = 1
type = "IIC"
completeOnly = TRUE
palette = "BASS"
thetaGrid = seq(-6, 6, length.out = 100)
writeout = FALSE
imageType = "pdf"
fileSuffix = NULL
origPar = par(no.readonly = TRUE) # so graphical parameters can be reset after
par(mai=c(1.36,1.093333,1.093333,0.56),
mar=c(5.1,4.1,4.1,2.1),
xpd=FALSE)
if (palette == "BASS") {
color <- c("gray52", "#80b1d3")
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(3, palette)
} else if (all(areColors(palette)) & length(palette) == 2) {
color <- palette
} else {
stop('palette must be "BASS", an RColorBrewer palette, or a character with 2 valid color specifications.')
}
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else if (is.numeric(dim)) {
D <- dim
}
K <- ncol(results$itemThres)
inclConsIDs <- results$consInfo$cons.ID[D]
inclItem <- results$itemInfo$cons.ID %in% inclConsIDs
probs <- lapply(thetaGrid, catProbs, itemThres = results$itemThres[inclItem,])
infoItem <- sapply(1:length(probs), function(x) {
expScore <- apply(probs[[x]], 2, function(y) {
sum(0:K * y, na.rm = TRUE)
})
colSums(sapply(1:length(expScore), function(y) {
((0:K - expScore[y]) ^ 2) * probs[[x]][,y]
}), na.rm = TRUE)
})
infoPers <- results$scoresRecoded[,inclItem]
if (type == "IIC") {
thetas <- results$scoresRecoded[,inclItem]
} else {
thetas <- results$persPars
}
for (d in D) {
fillCol <- which(results$itemInfo$cons.ID[inclItem] == results$consInfo$cons.ID[d])
for (n in 1:results$estSummary$N) {
infoPers[n, fillCol] <- infoItem[,which.min(abs(results$persPars[n, d] - thetaGrid))][fillCol]
if (type == "IIC") {
thetas[n, fillCol] = rep(thetaGrid[which.min(abs(results$persPars[n, d] - thetaGrid))], length(fillCol))
} else {
thetas[n, d] = thetaGrid[which.min(abs(results$persPars[n, d] - thetaGrid))]
}
}
}
# put NAs in if they didn't answer the question
infoPers[is.na(results$scoresRecoded[,inclItem])] <- NA
testInfo <- matrix(nrow = length(thetaGrid), ncol = results$estSummary$D)
testInfoPers <- matrix(nrow = results$estSummary$N, ncol = results$estSummary$D)
for (d in D) {
itemsD <- which(results$itemInfo$cons.ID[inclItem] == results$consInfo$cons.ID[d])
testInfo[,d] = colSums(infoItem[itemsD,])
testInfoPers[,d] = rowSums(infoPers[,itemsD], na.rm = TRUE)
}
if (completeOnly) {
persToPlot <- complete.cases(results$scoresRecoded)
} else {
persToPlot <- rep(TRUE, nrow(results$persPars))
}
inclItem
for (i in 1:sum(inclItem)) {
if(writeout) {
eval(parse(text = paste0(imageType, "('IIC-item", i, fileSuffix, ".",
imageType, "')")))
}
maxX <- 2 * ceiling(max(thetaGrid)/2)
minX <- 2 * floor(min(thetaGrid)/2)
plot(1, type = "n", xlim = c(min(thetaGrid), max(thetaGrid)),
ylim = c(0, max(infoItem[i,])), axes = FALSE,
xlab = "Logits", ylab = "Information",
main = "Item Information Curve")
mtext(as.character(results$itemInfo$item.name[i]))
lines(thetaGrid, infoItem[i,], lwd = 2, col = color[1])
axis(1, at = seq(minX, maxX, 2))
axis(1, at = seq(minX+1, maxX-1, 2), labels = FALSE)
axis(2)
points(thetas[,i], infoPers[,i], pch = 21, col = color[1], bg = color[2])
if (writeout) {
dev.off
}
}
devtools::load_all()
info.graph(AMY, type = "IIC", dim = 2) # error in this one
info.graph(AMY, type = "IIC", dim = 1) # error in this one
rm(list=ls())
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
info.graph(AMY, type = "IIC", dim = 1) # error in this one
info.graph(AMY, type = "IIC", dim = 2) # error in this one
AMY$itemInfo
results = AMY
dim = 1
type = "IIC"
completeOnly = TRUE
palette = "BASS"
writeout = FALSE
thetaGrid = seq(-6, 6, length.out = 100)
origPar = par(no.readonly = TRUE) # so graphical parameters can be reset after
par(mai=c(1.36,1.093333,1.093333,0.56),
mar=c(5.1,4.1,4.1,2.1),
xpd=FALSE)
if (palette == "BASS") {
color <- c("gray52", "#80b1d3")
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(3, palette)
} else if (all(areColors(palette)) & length(palette) == 2) {
color <- palette
} else {
stop('palette must be "BASS", an RColorBrewer palette, or a character with 2 valid color specifications.')
}
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else if (is.numeric(dim)) {
D <- dim
}
K <- ncol(results$itemThres)
inclConsIDs <- results$consInfo$cons.ID[D]
inclItem <- results$itemInfo$cons.ID %in% inclConsIDs
inclConsIDs
inclItem
sum(inclItem)
probs <- lapply(thetaGrid, catProbs, itemThres = results$itemThres[inclItem,])
infoItem <- sapply(1:length(probs), function(x) {
expScore <- apply(probs[[x]], 2, function(y) {
sum(0:K * y, na.rm = TRUE)
})
colSums(sapply(1:length(expScore), function(y) {
((0:K - expScore[y]) ^ 2) * probs[[x]][,y]
}), na.rm = TRUE)
})
infoPers <- results$scoresRecoded[,inclItem]
if (type == "IIC") {
thetas <- results$scoresRecoded[,inclItem]
} else {
thetas <- results$persPars
}
for (d in D) {
fillCol <- which(results$itemInfo$cons.ID[inclItem] == results$consInfo$cons.ID[d])
for (n in 1:results$estSummary$N) {
infoPers[n, fillCol] <- infoItem[,which.min(abs(results$persPars[n, d] - thetaGrid))][fillCol]
if (type == "IIC") {
thetas[n, fillCol] = rep(thetaGrid[which.min(abs(results$persPars[n, d] - thetaGrid))], length(fillCol))
} else {
thetas[n, d] = thetaGrid[which.min(abs(results$persPars[n, d] - thetaGrid))]
}
}
}
# put NAs in if they didn't answer the question
infoPers[is.na(results$scoresRecoded[,inclItem])] <- NA
testInfo <- matrix(nrow = length(thetaGrid), ncol = results$estSummary$D)
testInfoPers <- matrix(nrow = results$estSummary$N, ncol = results$estSummary$D)
for (d in D) {
itemsD <- which(results$itemInfo$cons.ID[inclItem] == results$consInfo$cons.ID[d])
testInfo[,d] = colSums(infoItem[itemsD,])
testInfoPers[,d] = rowSums(infoPers[,itemsD], na.rm = TRUE)
}
# flag complete cases
if (completeOnly) {
persToPlot <- complete.cases(results$scoresRecoded)
} else {
persToPlot <- rep(TRUE, nrow(results$persPars))
}
which(inclItem)
devtools::load_all()
info.graph(AMY, type = "IIC", dim = 2) # error in this one
which(inclItem)
i = 1
maxX <- 2 * ceiling(max(thetaGrid)/2)
minX <- 2 * floor(min(thetaGrid)/2)
plot(1, type = "n", xlim = c(min(thetaGrid), max(thetaGrid)),
ylim = c(0, max(infoItem[i,])), axes = FALSE,
xlab = "Logits", ylab = "Information",
main = "Item Information Curve")
mtext(as.character(results$itemInfo$item.name[i]))
lines(thetaGrid, infoItem[i,], lwd = 2, col = color[1])
axis(1, at = seq(minX, maxX, 2))
axis(1, at = seq(minX+1, maxX-1, 2), labels = FALSE)
axis(2)
points(thetas[,i], infoPers[,i], pch = 21, col = color[1], bg = color[2])
i = 2
dim(infoItem)
itemInfo <- results$itemInfo
itemInfo <- results$itemInfo[inclItem,]
View(itemInfo)
View(infoPers)
probs <- lapply(thetaGrid, catProbs, itemThres = results$itemThres[inclItem,])
infoItem <- sapply(1:length(probs), function(x) {
expScore <- apply(probs[[x]], 2, function(y) {
sum(0:K * y, na.rm = TRUE)
})
colSums(sapply(1:length(expScore), function(y) {
((0:K - expScore[y]) ^ 2) * probs[[x]][,y]
}), na.rm = TRUE)
})
infoPers <- results$scoresRecoded[,inclItem]
if (type == "IIC") {
thetas <- results$scoresRecoded[,inclItem]
} else {
thetas <- results$persPars
}
for (d in D) {
fillCol <- which(results$itemInfo$cons.ID[inclItem] == results$consInfo$cons.ID[d])
for (n in 1:results$estSummary$N) {
infoPers[n, fillCol] <- infoItem[,which.min(abs(results$persPars[n, d] - thetaGrid))][fillCol]
if (type == "IIC") {
thetas[n, fillCol] = rep(thetaGrid[which.min(abs(results$persPars[n, d] - thetaGrid))], length(fillCol))
} else {
thetas[n, d] = thetaGrid[which.min(abs(results$persPars[n, d] - thetaGrid))]
}
}
}
# put NAs in if they didn't answer the question
infoPers[is.na(results$scoresRecoded[,inclItem])] <- NA
testInfo <- matrix(nrow = length(thetaGrid), ncol = results$estSummary$D)
testInfoPers <- matrix(nrow = results$estSummary$N, ncol = results$estSummary$D)
for (d in D) {
itemsD <- which(results$itemInfo$cons.ID[inclItem] == results$consInfo$cons.ID[d])
testInfo[,d] = colSums(infoItem[itemsD,])
testInfoPers[,d] = rowSums(infoPers[,itemsD], na.rm = TRUE)
}
# flag complete cases
if (completeOnly) {
persToPlot <- complete.cases(results$scoresRecoded)
} else {
persToPlot <- rep(TRUE, nrow(results$persPars))
}
devtools::load_all()
info.graph(AMY, type = "IIC", dim = 2) # error in this one
info.graph(AMY, type = "IIC", dim = 1)
View(thetas)
View(testInfoPers)
View(testInfoPers)
View(thetas)
rm(list=ls())
load("C:/Users/Amy/OneDrive/Development/crasch/.RData")
AMY$persFit
KIDMAP(AMY, personID = 131)
KIDMAP(AMY, personID = "131")
results = AMY
personID = 131
AMY$persPars
KIDMAP(AMY, personID = 131)
KIDMAP(AMY, personID = "131")
KIDMAP(AMY, personID = "131", dim = 2)
names(results)
?exists
exists(results$itemPars)
exists('results$itemPars')
names(results)
class(results$itemPars)
class(results$itemSEs)
class(results$itemThres)
class(results$itemFit)
class(results$persPars)
class(results$persSEs)
class(results$persRaw)
class(results$persMax)
class(persFit)
class(results$persFit)
class(results$popDist)
class(results$sepRel)
?is.list
class(results$estSummary)
class(results$classicalStats)
class(results$empties)
class(results$scoresOrig)
class(results$scoresRecoded)
class(results$itemInfo)
class(results$consInfo)
class(results$varsInfo)
length(results)
lappy(results, is.null)
lapply(results, is.null)
sapply(results, is.null)
any(sapply(results, is.null))
devtools::load_all()
KIDMAP(results)
KIDMAP(AMY, personID = 1)
length(AMY)
devtools::load_all()
KIDMAP(AMY, personID = 1)
devtools::load_all()
KIDMAP(AMY, personID = 1)
devtools::load_all()
KIDMAP(AMY, personID = 1)
devtools::load_all()
KIDMAP(AMY, personID = 1)
KIDMAP(AMY, personID = 131)
KIDMAP(AMY, personID = 131, imageType = "poop")
personID = "131"
as.character(personID) %in% row.names(results$scoresOrig) &
length(personID) == 1 &
(is.character(personID) | is.numeric(personID))
!(as.character(personID) %in% row.names(results$scoresOrig) &
length(personID) == 1 &
(is.character(personID) | is.numeric(personID)))
probBounds = c(.25, .75)
?all
all(probBounds <= 1 & probBounds >= 0)
(!(length(probBounds) == 2 &
all(probBounds <= 1 & probBounds >= 0) &
(probBounds[1] <= probBounds[2])))
(probBounds[1] <= probBounds[2])
View(AMY$itemInfo)
minCell = 8
minCell %% 1
minCell %% 3
minCell %% 4
8.4 %% 1
!(is.numeric(minCell) & minCell > 0 & minCell %% 1 != 0)
focusTheta = c(-2,0,2)
is.numeric(focusTheta)
itemInfo <- AMY$itemInfo
View(itemInfo)
length(unique(itemInfo$item.ID)) != nrow(itemInfo)
devtools::load_all()
pers.hist(AMY)
pers.hist(AMY, dim = 2)
pers.hist(AMY, dim = 2.1)
devtools::load_all()
infit.MNSQ(AMY)
infit.MNSQ(AMY, itemOrder = c(1,3,5))
infit.MNSQ(AMY, itemOrder = "poop")
devtools::load_all()
infit.MNSQ(AMY, itemOrder = "poop")
devtools::load_all()
infit.MNSQ(AMY, itemOrder = "poop")
wm(AMY, itemOrder = 1:4) # errors/warnings -- look into this next time!
wm(AMY, itemOrder = 1:5) # errors/warnings -- look into this next time!
devtools::load_all()
wm(AMY)
devtools::load_all()
wm(AMY)
wm(AMY, byCat = TRUE)
CPC.graph(AMY, palette = "PuBu")
?CPC.graph
devtools::load_all()
CPC.graph(AMY, palette = "PuBu")
!(is.numeric(minCell) & minCell > 0 & minCell %% 1 != 0)
is.numeric(minCell)
minCell > 0
minCell %% 1 != 0
devtools::load_all()
CPC.graph(AMY, palette = "PuBu")
devtools::load_all()
CPC.graph(AMY, palette = "PuBu")
devtools::load_all()
CPC.graph(AMY, palette = "PuBu")
devtools::load_all()
CPC.graph(AMY, palette = "PuBu")
devtools::load_all()
CPC.graph(AMY, palette = "PuBu")
CPC.graph(AMY, palette = "BASS")
CPC.graph(AMY, palette = "gray")
devtools::load_all()
CPC.graph(AMY, palette = "gray")
devtools::load_all()
CPC.graph(AMY, palette = "gray")
CPC.graph(AMY, palette = "BASS")
CPC.graph(AMY, palette = "PuBu")
library(testthat)
?expect_error
names(AMY)
AMY$varsInfo
devtools::test()
devtools::test()
devtools::test()
craschR(scores = ADPwide, itemInfo = ADPitem,
consInfo = ADPcons, varsInfo = ADPvars,
estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
craschR(scores = SUPwide, itemInfo = SUPitem,
consInfo = SUPcons, varsInfo = SUPvars,
estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
?craschR
craschR(scores = SUPwide, itemInfo = SUPitem,
consInfo = SUPcons, varsInfo = SUPvars,
estPackage = "TAM", retainOrig = TRUE,
consecutive = FALSE, writeout = FALSE)
devtools::test()
test = craschR(scores = SUPwide, itemInfo = SUPitem,
consInfo = SUPcons, varsInfo = SUPvars,
estPackage = "TAM", retainOrig = TRUE,
consecutive = FALSE, writeout = FALSE)
devtools::load_all()
test = craschR(scores = SUPwide, itemInfo = SUPitem,
consInfo = SUPcons, varsInfo = SUPvars,
estPackage = "TAM", retainOrig = TRUE,
consecutive = FALSE, writeout = FALSE)
devtools::test()
devtools::test()
bad <- craschR(scores = AMYwide, itemInfo = SUPitem,
consInfo = SUPcons, varsInfo = SUPvars,
estPackage = "TAM", retainOrig = TRUE,
consecutive = FALSE, writeout = FALSE)
bad$estSummary
nrow(bad$itemInfo) != ncol(bad$scoresOrig)
nrow(bad$itemInfo)
ncol(bad$scoresOrig)
devtools::test()
devtools::test()
