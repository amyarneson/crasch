par(mar = rep(0, 4))
plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-10,10),
ylim = c(-10, 10))
legend(x = "center", xjust = .5, legend = row.names(tograph), pch = 22,
col = "black", pt.bg = color, horiz = TRUE, pt.cex = 2,
text.width = 20/nrow(tograph))
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = rep(0, 4))
plot(1, type = "n"
)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = rep(.1, 4))
plot(1, type = "n"
)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = rep(.5, 4))
plot(1, type = "n"
)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = rep(1, 4))
plot(1, type = "n"
)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = rep(2, 4))
plot(1, type = "n"
)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = c(2,0,0,0))
plot(1, type = "n
)
)
)
)
dsjflksj
")
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = c(2,0,0,0))
plot(1, type = "n", axes = TRUE, xlab = "", ylab = "", xlim = c(-10,10),
ylim = c(-10, 10)
)
legend(x = "center", xjust = .5, legend = row.names(tograph), pch = 22,
col = "black", pt.bg = color, horiz = TRUE, pt.cex = 2,
text.width = 10/nrow(tograph))
layout(matrix(1:2, nrow = 2), heights = c(5, 1))
par(xpd = TRUE)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = c(2,0,0,0))
plot(1, type = "n", axes = TRUE, xlab = "", ylab = "", xlim = c(-10,10),
ylim = c(-10, 10))
legend(x = "center", xjust = .5, legend = row.names(tograph), pch = 22,
col = "black", pt.bg = color, horiz = TRUE, pt.cex = 2,
text.width = 10/nrow(tograph))
layout(matrix(1:2, nrow = 2), heights = c(5, 1))
par(xpd = TRUE)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = c(2,0,0,0))
plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-10,10),
ylim = c(-10, 10))
legend(x = "center", xjust = .5, legend = row.names(tograph), pch = 22,
col = "black", pt.bg = color, horiz = TRUE, pt.cex = 2,
text.width = 10/nrow(tograph))
# text.width uses 10 because the plot I created is 20 wide & must account
#   for size of boxes. Hopefully this will work for a reasonable number
#   of levels.
layout(matrix(1:2, nrow = 2), heights = c(5, 1))
par(xpd = TRUE)
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = c(2,0,0,0))
plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-10,10),
ylim = c(-10, 10))
legend(x = "center", xjust = .5, legend = row.names(tograph), pch = 22,
col = "black", pt.bg = color, horiz = TRUE, pt.cex = 2, bty = "n",
text.width = 10/nrow(tograph))
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = c(2,0,0,0))
plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-5, 5),
ylim = c(-5, 5))
legend(x = "center", xjust = .5, legend = row.names(tograph), pch = 22,
col = "black", pt.bg = color, horiz
= TRUE, pt.cex = 2, bty = "n",
text.width = 10/nrow(tograph))
par(mar = c(2, 4, 4, 2) + 0.1)
barplot(cbind(tograph[,seq(ncol(tograph), 1, -1)]),
col = color, horiz = TRUE, las = 1,
main = paste0(cons$short.name,", Scores by Item"))
par(mar = c(2,0,0,0))
plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-5, 5),
ylim = c(-5, 5))
legend(x = "center", xjust = .5, legend = row.names(tograph), pch = 22,
col = "black", pt.bg = color, horiz = TRUE, pt.cex = 2, bty = "n",
text.width = 5/nrow(tograph))
devtools::load_all()
devtools::build()
devtools::load_all()
infit.MNSQ(ADP, itemOrder = 1)
?infit.MNSQ
infit.MNSQ(ADP, params = "steps", itemOrder = 1)
?ICC.graph
?CPC.graph
CPC.graph(ADP, itemOrder = 1)
ICC.graph(ADP, itemOrder = 1)
?mean.traj
?mn.traj
mn.traj(ADP, itemOrder = 1)
results = ADP
itemOrder = 1
params = "items"
checkResults(results)
checkItemOrder(itemOrder, results$itemInfo)
if (!params %in% c("items", "steps")) {
stop('Invalid params argument.')
}
# error if all items are dichotomous
if (ncol(results$itemPars) == 1) {
stop('All items are dichotomous. There are no step parameters. Use params="items".')
}
origPar = par(no.readonly = TRUE) # to reset graphical parameters after
if (is.null(itemOrder)) {
plotOrder <- 1:results$estSummary$I
} else if (is.numeric(itemOrder)) {
plotOrder <- itemOrder
} else {
stop('Invalid itemOrder argument.')
}
toPlot <- data.frame(infit = results$itemFit$infit[plotOrder])
row.names(toPlot) <- results$itemInfo$item.name[plotOrder]
if (params == "items") {
toPlot <- data.frame(infit = results$itemFit$infit[plotOrder])
row.names(toPlot) <- results$itemInfo$item.name[plotOrder]
} else if (params == "steps") {
if (is.null(itemOrder)) {
toPlot <- data.frame(infit = results$itemFit$infit[(results$estSummary$I+1):nrow(results$itemFit)])
row.names(toPlot) <- results$itemFit$item[(results$estSummary$I+1):nrow(results$itemFit)]
} else {
fullMatrix <- data.frame(
as.matrix(stringr::str_split_fixed(as.character(results$itemFit$item[(results$estSummary$I+1):nrow(results$itemFit)]),
'_step', n = 2)),
infit = results$itemFit$infit[(results$estSummary$I+1):nrow(results$itemFit)])
colnames(fullMatrix) <- c("item", "step", "infit")
redMatrix <- reshape(fullMatrix, idvar = "item", timevar = "step",
direction = "wide")
# dichotomous items will not show up w/step params - account for this
if (any(apply(results$scoresRecoded, 2, max, na.rm = TRUE) == 1)) {
insertRows <- which(apply(results$scoresRecoded, 2, max, na.rm = TRUE) == 1)
for (i in insertRows) {
if (i == 1) {
redMatrix = rbind(rep(NA, ncol(redMatrix)), redMatrix)
} else if (i == results$estSummary$I) {
redMatrix = rbind(redMatrix, rep(NA, ncol(redMatrix)))
} else {
redMatrix = rbind(redMatrix[1:(i-1),], rep(NA, ncol(redMatrix)),
redMatrix[i:nrow(redMatrix),])
}
}
}
redMatrix = redMatrix[plotOrder,]
redMatrix = reshape(redMatrix)
redMatrix = redMatrix[complete.cases(redMatrix),]
toPlot <- data.frame(infit = redMatrix[,3])
row.names(toPlot) <- paste(redMatrix[,1], redMatrix[,2], sep = "_step")
}
} else {
stop('Invalid params argument.')
}
} else { # fill in once mirt portion is written
if (params == "items") {
} else if (params == "steps") {
} else {
stop('Invalid params argument.')
}
}
if (results$estSummary$estPackage == "TAM") {
if (params == "items") {
toPlot <- data.frame(infit = results$itemFit$infit[plotOrder])
row.names(toPlot) <- results$itemInfo$item.name[plotOrder]
} else if (params == "steps") {
if (is.null(itemOrder)) {
toPlot <- data.frame(infit = results$itemFit$infit[(results$estSummary$I+1):nrow(results$itemFit)])
row.names(toPlot) <- results$itemFit$item[(results$estSummary$I+1):nrow(results$itemFit)]
} else {
fullMatrix <- data.frame(
as.matrix(stringr::str_split_fixed(as.character(results$itemFit$item[(results$estSummary$I+1):nrow(results$itemFit)]),
'_step', n = 2)),
infit = results$itemFit$infit[(results$estSummary$I+1):nrow(results$itemFit)])
colnames(fullMatrix) <- c("item", "step", "infit")
redMatrix <- reshape(fullMatrix, idvar = "item", timevar = "step",
direction = "wide")
# dichotomous items will not show up w/step params - account for this
if (any(apply(results$scoresRecoded, 2, max, na.rm = TRUE) == 1)) {
insertRows <- which(apply(results$scoresRecoded, 2, max, na.rm = TRUE) == 1)
for (i in insertRows) {
if (i == 1) {
redMatrix = rbind(rep(NA, ncol(redMatrix)), redMatrix)
} else if (i == results$estSummary$I) {
redMatrix = rbind(redMatrix, rep(NA, ncol(redMatrix)))
} else {
redMatrix = rbind(redMatrix[1:(i-1),], rep(NA, ncol(redMatrix)),
redMatrix[i:nrow(redMatrix),])
}
}
}
redMatrix = redMatrix[plotOrder,]
redMatrix = reshape(redMatrix)
redMatrix = redMatrix[complete.cases(redMatrix),]
toPlot <- data.frame(infit = redMatrix[,3])
row.names(toPlot) <- paste(redMatrix[,1], redMatrix[,2], sep = "_step")
}
} else {
stop('Invalid params argument.')
}
} else { # fill in once mirt portion is written
if (params == "items") {
} else if (params == "steps") {
} else {
stop('Invalid params argument.')
}
}
if (identical(palette, "BASS")) {
color <- c(acceptable = rgb(red = 128, green = 177, blue = 211,
alpha = 127.5, maxColorValue = 255),
points = "#80b1d3")
} else if (length(palette) == 1) {
if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(3, palette)
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette)) & length(palette)==2) {
color <- palette
} else {
stop('Invalid palette argument.')
}
palette = "BASS"
if (results$estSummary$estPackage == "TAM") {
if (params == "items") {
toPlot <- data.frame(infit = results$itemFit$infit[plotOrder])
row.names(toPlot) <- results$itemInfo$item.name[plotOrder]
} else if (params == "steps") {
if (is.null(itemOrder)) {
toPlot <- data.frame(infit = results$itemFit$infit[(results$estSummary$I+1):nrow(results$itemFit)])
row.names(toPlot) <- results$itemFit$item[(results$estSummary$I+1):nrow(results$itemFit)]
} else {
fullMatrix <- data.frame(
as.matrix(stringr::str_split_fixed(as.character(results$itemFit$item[(results$estSummary$I+1):nrow(results$itemFit)]),
'_step', n = 2)),
infit = results$itemFit$infit[(results$estSummary$I+1):nrow(results$itemFit)])
colnames(fullMatrix) <- c("item", "step", "infit")
redMatrix <- reshape(fullMatrix, idvar = "item", timevar = "step",
direction = "wide")
# dichotomous items will not show up w/step params - account for this
if (any(apply(results$scoresRecoded, 2, max, na.rm = TRUE) == 1)) {
insertRows <- which(apply(results$scoresRecoded, 2, max, na.rm = TRUE) == 1)
for (i in insertRows) {
if (i == 1) {
redMatrix = rbind(rep(NA, ncol(redMatrix)), redMatrix)
} else if (i == results$estSummary$I) {
redMatrix = rbind(redMatrix, rep(NA, ncol(redMatrix)))
} else {
redMatrix = rbind(redMatrix[1:(i-1),], rep(NA, ncol(redMatrix)),
redMatrix[i:nrow(redMatrix),])
}
}
}
redMatrix = redMatrix[plotOrder,]
redMatrix = reshape(redMatrix)
redMatrix = redMatrix[complete.cases(redMatrix),]
toPlot <- data.frame(infit = redMatrix[,3])
row.names(toPlot) <- paste(redMatrix[,1], redMatrix[,2], sep = "_step")
}
} else {
stop('Invalid params argument.')
}
} else { # fill in once mirt portion is written
if (params == "items") {
} else if (params == "steps") {
} else {
stop('Invalid params argument.')
}
}
if (identical(palette, "BASS")) {
color <- c(acceptable = rgb(red = 128, green = 177, blue = 211,
alpha = 127.5, maxColorValue = 255),
points = "#80b1d3")
} else if (length(palette) == 1) {
if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(3, palette)
} else {
stop('Invalid palette argument.')
}
} else if (all(areColors(palette)) & length(palette)==2) {
color <- palette
} else {
stop('Invalid palette argument.')
}
layout(matrix(1, nrow = 1))
dotchart(x = rev(toPlot[,1]), rev(row.names(toPlot)),
main = "Infit Mean Squares", xlab = "Infit MNSQ", ylab = "",
xlim = c(min(.7, min(toPlot[,1])), max(1.4, max(toPlot[,1]))),
pch = ".")
observed = FALSE
minCell = 8
focusTheta = c(-2,0,2)
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
itemThres <- results$itemThres[itemOrder,]
} else {
stop('itemOrder must be a numeric vector or NULL.')
}
I <- nrow(itemInfo)
for (i in 1:I) {
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (length(palette) == 1) {
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
fillcol = "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(max(K_i,3), palette)
fillcol = "white"
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
fillcol = "gray"
}  else {
stop('Invalid palette argument.')
}
} else {
stop('Invalid palette argument.')
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
plot(1, type = "n", xlim = c(-6, 6), ylim = c(0, 1), axes = FALSE,
xlab = "Logits", ylab = "Probability",
main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(1, at = seq(-6, 6, 2))
axis(1, at = seq(-5, 5, 2), labels = FALSE)
axis(2, at = seq(0, 1, .2), las = 1)
axis(2, at = seq(.1, .9, .2), labels = FALSE)
for (k in 1:K_i) {
if (observed) {
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,i]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,i]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i+1), 1, by = -1)]
} else {
linecol = "black"
vlinecol = "grey"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
}
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
if (observed) {
points(sort(unique(theta))[cellCts[,(k+1)] >= minCell],
empPts[cellCts[,(k+1)] >= minCell,(k+1)], col = color[k],
pch = 20)
} else {
abline(v = focusTheta, col = vlinecol, lty = 2, lwd = 2)
for (a in 1:length(focusTheta)) {
bounds <- boot::inv.logit(focusTheta[a] - thres)
L <- placement <- rep(NA, length(bounds) + 1)
for (k in 0:K_i) {
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K_i) {
loBd = 0
} else {
loBd = bounds[k+1]
}
L[k+1] = paste0("p(",k,")=", round(upBd - loBd, 2))
placement[k+1] = mean(c(upBd, loBd))
}
points(x = rep(focusTheta[a], length(bounds)), y = bounds, pch=21,
bg = fillcol)
text(x = rep(focusTheta[a], length(bounds) + 1), y = placement,
labels = L, pos = 4, cex = .5)
}
}
}
}
itemInfo
nrow(itemInfo)
i = 1
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
itemThres
class(itemThres)
itemThres <- data.frame(results$itemThres[itemOrder,])
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
devtools::load_all()
CPC.graph(ADP, itemOrder = 1)
CPC.graph(ADP, itemOrder = 15)
CPC.graph(ADP, itemOrder = 14)
CPC.graph(ADP, itemOrder = 13)
CPC.graph(ADP, itemOrder = 12)
CPC.graph(ADP, itemOrder = 11)
CPC.graph(ADP, itemOrder = 10)
CPC.graph(ADP)
itemThres <- matrix(results$itemThres)
itemThres
itemThres <- results$itemThres[itemOrder,]
itemOrder = 1:3
itemThres <- results$itemThres[itemOrder,]
itemThres
class(itemThres)
itemOrder = 1
matrix(results$itemThres[itemOrder,])
results$itemThres[itemOrder,
]
matrix(results$itemThres[itemOrder,], nrow = 1)
?matrix
matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(itemThres)))
devtools::load_all()
CPC.graph(ADP, itemOrder = 10)
CPC.graph(ADP)
CPC.graph(ADP, itemOrder = 15)
CPC.graph(ADP, itemOrder = 13)
devtools::load_all()
ICC.graph(ADP, itemOrder = 13)
ICC.graph(ADP)
ICC.graph(ADP, itemOrder = 13)
mn.traj(ADP, itemOrder = 1:2)
mn.traj(ADP, itemOrder = 1)
results = ADP
itemOrder = 1
itemOrder = 13
palette = "BASS"
itemInfo <- results$itemInfo[itemOrder,]
itemInfo
scoresRecoded <- results$scoresRecoded[,itemOrder]
scoresRecoded
itemOrder = 1:2
scoresRecoded <- results$scoresRecoded[,itemOrder]
scoresRecoded
class(scoresRecoded)
results$scoresRecoded[,itemOrder]
itemOrder = 1
data.frame(results$scoresRecoded[,itemOrder])
row.names(scoresRecoded) = row.names(results$scoresRecoded)
scoresRecoded
scoresRecoded <- data.frame(results$scoresRecoded[,itemOrder])
row.names(scoresRecoded) = row.names(results$scoresRecoded)
scoresRecoded
colnames(scoresRecoded) = colnames(results$scoresRecoded)[itemOrder]
head(scoresRecoded)
devtools::load_all()
mn.traj(ADP, itemOrder = 13)
mn.traj(ADP)
mn.traj(ADP, itemOrder = 12:13)
devtools::build()
