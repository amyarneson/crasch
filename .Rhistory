# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 2
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 3
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 4
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 5
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 6
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 7
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 8
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 9
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 10
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
results$estSummary$I
i =11
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
i = 12
cons = which(results$consInfo$cons.ID == results$itemInfo$cons.ID[i]) # row index
K_i = sum(as.logical(results$itemInfo[i, 6:ncol(results$itemInfo)]))
fill = c(start:(start + K_i - 1))
# item, construct, and category (construct specific) names
byStep$Item[fill] = rep(results$itemInfo$item.name[i], K_i)
byStep$Construct[fill] = rep(results$consInfo$short.name[cons], K_i)
byStep$Cat[fill] = as.matrix(results$consInfo[cons,4:ncol(results$consInfo)][which(results$itemInfo[i,6:ncol(results$itemInfo)]==1)])
# figure out which categories are empty
if (length(results$empties[[i]]) > 0) {
byStep[fill[(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]] )], 4] = 0
# skip all empty categories for remaining statistics
fill = fill[!(byStep$Cat[fill] %in% results$consInfo[cons,4:ncol(results$consInfo)][results$empties[[i]]])]
}
# counts per category
byStep$Count[fill] = table(results$scoresRecoded[,i])
# recoded scores
byStep$Score[fill] = 0:(length(fill) - 1)
# location estimates and standard errors
byStep$Estimate[fill[-1]] = results$itemPars[i,2:(length(fill))]
byStep$SE_est[fill[-c(1,length(fill))]] = results$itemSEs[i,2:(length(fill) - 1)]
# thresholds
byStep$Threshold[fill[-1]] = results$itemThres[i,1:(length(fill) - 1)]
# point biserials
byStep$PtBiserial[fill] = sapply(fill,function(x) {
-ltm::biserial.cor(persProp[!is.na(results$scoresRecoded[,i]),cons],
results$scoresRecoded[!is.na(results$scoresRecoded[,i]),i]==byStep$Score[x])
})
# person locations
byStep$MeanPersLoc[fill] = sapply(fill,function(x) {
mean(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
byStep$SD_PersLoc[fill] = sapply(fill,function(x) {
sd(results$persPars[results$scoresRecoded[!is.na(results$scoresRecoded[,i]), i] == byStep$Score[x], cons],
na.rm = TRUE)
})
start = start + K_i
empties
results$empties
results$scoresOrig[,c(6,12)]
table(results$scoresOrig[,6])
table(results$scoresOrig[,12])
View(itemInfo)
results$empties
View(GC_scores)
table(results$scoresOrig[,1])
table(results$scoresOrig[,2])
table(results$scoresOrig[,3])
table(results$scoresOrig[,4])
table(results$scoresOrig[,5])
table(results$scoresOrig[,6])
table(results$scoresOrig[,7])
table(results$scoresOrig[,8])
table(results$scoresOrig[,9])
table(results$scoresOrig[,10])
table(results$scoresOrig[,11])
table(results$scoresOrig[,12])
wide = results$scoresOrig
itemScoreInfo = t(itemInfo[,6:ncol(itemInfo)])
itemScoreInfo
I = ncol(wide)
item.list = list()
i = 1
which(!which(itemScoreInfo[,i]) %in% wide[,i])
for (i in 1:I) {
item.list[[i]] <- which(!(which(itemScoreInfo[,i]) %in% wide[,i]))
}
item.list
i = 6
which(!(which(itemScoreInfo[,i]) %in% wide[,i]))
itemScoreInfo[,i]
wide[,i]
which(itemScoreInfo[,i])
wide[,i]
which(itemScoreInfo[,i])
unique(wide[,i])
?unique
which(itemScoreInfo[,i]) %in% unique(wide[,i])
which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
i = 12
which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
i = 2
which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
empty.cats <- function(wide,
itemScoreInfo) {
I = ncol(wide)
item.list = list()
for (i in 1:I) {
item.list[[i]] <- which(itemScoreInfo[,i])[!(which(itemScoreInfo[,i]) %in% unique(wide[,i]))]
}
return(item.list)
}
devtools::load_all
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
GC_cons = read.csv("GC_cons (1).csv", stringsAsFactors = FALSE)
GC_item = read.csv("GC_item (1).csv", stringsAsFactors = FALSE)
GC_scores = read.csv("GC_wide (1).csv", row.names = 1, stringsAsFactors = FALSE)
#GC_vars = read.csv("GC_vars (1).csv", row.names = 1, stringsAsFactors = FALSE)
GC_analysis = craschR(scores = GC_scores, itemInfo = GC_item,
consInfo = GC_cons, writeout = TRUE)
wm(GC_analysis) # organized in item order
wm(GC_analysis, byCat = TRUE) # organized in construct category order
setwd("C:/Users/Amy/Desktop/Laura2")
library(crasch)
GC_cons = read.csv("GC_cons (1).csv", stringsAsFactors = FALSE)
GC_item = read.csv("GC_item (1).csv", stringsAsFactors = FALSE)
GC_scores = read.csv("GC_wide (1).csv", row.names = 1, stringsAsFactors = FALSE)
#GC_vars = read.csv("GC_vars (1).csv", row.names = 1, stringsAsFactors = FALSE)
GC_analysis = craschR(scores = GC_scores, itemInfo = GC_item,
consInfo = GC_cons, writeout = TRUE)
wm(GC_analysis) # organized in item order
wm(GC_analysis, byCat = TRUE) # organized in construct category order
