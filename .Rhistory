cellCts = t(apply(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
checkResults(results)
checkWrite(writeout, fileSuffix)
checkImageType(imageType)
checkItemOrder(itemOrder, results$itemInfo)
if (!is.logical(observed)) {
stop('Invalid observed argument.')
}
if (!(is.numeric(minCell) & (minCell > 0) & (minCell %% 1 == 0))) {
stop('Invalid minCell argument.')
}
if (!is.numeric(focusTheta)) {
stop('Invalid focusTheta argument.')
}
if (minCell < 10 & observed) {
warning('Low cell counts (<10) will be graphed. Interpret with caution.')
}
if (is.null(itemOrder)) {
itemInfo <- results$itemInfo
itemThres <- results$itemThres
} else if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
if (length(itemOrder) == 1) {
itemThres <- matrix(results$itemThres[itemOrder,], nrow = 1,
dimnames = list(NULL, colnames(results$itemThres)))
} else {
itemThres <- results$itemThres[itemOrder,]
}
} else {
stop('itemOrder must be a numeric vector or NULL.')
}
I <- nrow(itemInfo)
i = 1
K_i <- sum(!is.na(itemThres[i,]))
thres <- c(itemThres[i, !is.na(itemThres[i,])], Inf)
if (length(palette) == 1) {
if (palette == "BASS") {
if (K_i == 2) {
color = rgb(red = 128, green = 177, blue = 211, alpha = c(140,255),
maxColorValue = 255)
} else {
color = rgb(red = 128, green = 177, blue = 211,
alpha = seq(80, 255, length.out = K_i), maxColorValue = 255)
}
fillcol = "#80b1d3"
} else if (palette %in% row.names(brewer.pal.info)) {
color <- brewer.pal(max(K_i,3), palette)
fillcol = "white"
} else if (palette == "grey" | palette == "gray") {
if (K_i == 2) {
color = gray(level = c(.75, .6))
} else {
color = gray(level = seq(from = .75, to = .25, length.out = K_i))
}
fillcol = "gray"
}  else {
stop('Invalid palette argument.')
}
} else {
stop('Invalid palette argument.')
}
layout(matrix(1))
par(mai = c(1.36, 1.093333, 1.093333, 0.56), mar = c(5.1, 4.1, 4.1, 2.1))
if (logitAxis == "x") {
xlim = c(-6, 6)
ylim = c(0, 1)
xlab = "Logits"
ylab = "Probability"
logits = 1
probability = 2
} else {
ylim = c(-6, 6)
xlim = c(0, 1)
ylab = "Logits"
xlab = "Probability"
logits = 2
probability = 1
}
plot(1, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab,
axes = FALSE, main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(logits, at = seq(-6, 6, 2))
axis(logits, at = seq(-5, 5, 2), labels = FALSE)
axis(probability, at = seq(0, 1, .2), las = 1)
axis(probability, at = seq(.1, .9, .2), labels = FALSE)
k = 1
linecol = color[k]
# group thetas at nearest .5 value for simplicity & to deal with sparse cells
theta <- round(results$persPars[,which(results$consInfo$cons.ID ==
itemInfo$cons.ID[i])]/.5) * .5
empPts = t(apply(prop.table(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])]),
margin = 1), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
cellCts = t(apply(table(theta, results$scoresRecoded[,which(results$itemInfo$item.ID == itemInfo$item.ID[i])]), 1,
function(x) {
cumsum(rev(x))
}))[,seq((K_i + 1), 1, by = -1)]
if (logitAxis == "x") {
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
} else {
curve(log(x / (1 - x)) + thres[k], from = 0, to = 1, add = TRUE,
col = linecol, lwd = 2)
}
x = sort(unique(theta))[cellCts[,(k+1)] >= minCell]
y = empPts[cellCts[,(k+1)] >= minCell,(k+1)]
if (logitAxis == "x") {
points(x, y, col = color[k], pch = 20)
lines(x, y, col = color[k], lwd = 2, lty = 2)
} else {
points(y, x, col = color[k], pch = 20)
lines(y, x, col = color[k], lwd = 2, lty = 2)
}
plot(1, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab,
axes = FALSE, main = "Cumulative Category Probability Curves")
mtext(as.character(itemInfo$item.name[i]))
axis(logits, at = seq(-6, 6, 2))
axis(logits, at = seq(-5, 5, 2), labels = FALSE)
axis(probability, at = seq(0, 1, .2), las = 1)
axis(probability, at = seq(.1, .9, .2), labels = FALSE)
linecol = "black"
vlinecol = "grey"
x <- c(seq(from = -6, to = 6, length.out = 500))
y1 <- c(boot::inv.logit(x - thres[k]))
y2 <- c(boot::inv.logit(x - thres[k+1]))
if (logitAxis == "x") {
polygon(c(x, rev(x)), c(y1, rev(y2)), col = color[k], border = NA)
} else {
polygon(c(y1, rev(y2)), c(x, rev(x)), col = color[k], border = NA)
}
if (logitAxis == "x") {
curve(boot::inv.logit(x - thres[k]), from = -6, to = 6, add = TRUE,
col = linecol, lwd = 2)
} else {
curve(log(x / (1 - x)) + thres[k], from = 0, to = 1, add = TRUE,
col = linecol, lwd = 2)
}
if (logitAxis == "x") {
abline(v = focusTheta, col = vlinecol, lty = 2, lwd = 2)
} else {
abline(h = focusTheta, col = vlinecol, lty = 2, lwd = 2)
}
for (a in 1:length(focusTheta)) {
bounds <- boot::inv.logit(focusTheta[a] - thres)
L <- placement <- rep(NA, length(bounds) + 1)
for (k in 0:K_i) {
if (k == 0) {
upBd = 1
} else {
upBd = bounds[k]
}
if (k == K_i) {
loBd = 0
} else {
loBd = bounds[k+1]
}
L[k+1] = paste0("p(",k,")=", round(upBd - loBd, 2))
placement[k+1] = mean(c(upBd, loBd))
}
x1 = rep(focusTheta[a], length(bounds))
x2 = rep(focusTheta[a], length(bounds) + 1)
if (logitAxis == "x") {
points(x1, bounds, pch=21, bg = fillcol)
text(x2, placement, labels = L, pos = 4, cex = .5)
} else {
points(bounds, x1, pch=21, bg = fillcol)
text(placement, x2, labels = L, pos = 4, cex = .5)
}
}
devtools::load_all()
CPC.graph(ADP, itemOrder = 1)
CPC.graph(ADP, itemOrder = 1, observed = TRUE)
CPC.graph(ADP, itemOrder = 2)
CPC.graph(ADP, itemOrder = 2, observed = TRUE)
CPC.graph(ADP, itemOrder = 3, observed = TRUE)
CPC.graph(ADP, itemOrder = 4, observed = TRUE)
CPC.graph(ADP, itemOrder = 5, observed = TRUE)
CPC.graph(ADP, itemOrder = 6, observed = TRUE)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2, logitAxis = "y")
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y")
devtools::load_all
devtools::load_all()
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y")
devtools::load_all()
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y")
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "y", focusTheta = 0)
CPC.graph(ADP, itemOrder = 6, observed = FALSE, minCell = 2, logitAxis = "x", focusTheta = 0)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2, logitAxis = "x", focusTheta = 0)
CPC.graph(ADP, itemOrder = 6, observed = TRUE, minCell = 2, logitAxis = "y", focusTheta = 0)
if (length(logitAxis) != 1) {
stop('Invalid logitAxis argument.')
} else {
if (logitAxis == "x") {
logitX = TRUE
} else if (logitAxis == "y") {
logitX = FALSE
} else {
stop('Invalid logitAxis argument.')
}
}
devtools::load_all()
devtools::build()
devtools::document()
devtools::build()
devtools::load_all()
?data.frame
devtools::load_all()
?craschR
craschR(SUPwide, SUPitem, SUPcons)
SUP<- craschR(SUPwide, SUPitem, SUPcons)
SUP$persFit
devtools::build()
?Sp.rho
?crasch::Sp.rho
rm(list=ls())
SEcons = read.csv("C:/Users/Amy/Desktop/Jordan/cronbach error/SE.Cons.csv", stringsAsFactors = FALSE)
SEitem = read.csv("C:/Users/Amy/Desktop/Jordan/cronbach error/SE.item.info.csv", stringsAsFactors = FALSE)
SEscores = read.csv("C:/Users/Amy/Desktop/Jordan/cronbach error/SE.Data.Wide.csv", row.names = 1, stringsAsFactors = FALSE)
SEvars = read.csv("C:/Users/Amy/Desktop/Jordan/cronbach error/SE.Vars.csv", row.names = 1, stringsAsFactors = FALSE)
View(SEcons)
dim(SEcons)
item1 = SEitem[c(2, 5, 7, 8, 10, 11, 14), ]
# selects rows
scores1 = SEscores[ , c(2, 5, 7, 8, 10, 11, 14)]
item2 = SEitem[c(1, 3, 4, 6, 9, 12, 13), ]
scores2 = SEscores[ , c(1, 3, 4, 6, 9, 12, 13)]
results1 = craschR(scores1, item1, SEcons, writeout = TRUE)
devtools::load_all()
results1 = craschR(scores1, item1, SEcons, writeout = TRUE)
library(crasch)
results1 = craschR(scores1, item1, SEcons, writeout = TRUE)
?craschR
?item.scores
devtools::load_all()
install.packages('Hmisc')
install.packages("Hmisc")
devtools::load_all()
results1 = craschR(scores1, item1, SEcons, writeout = TRUE)
results2 = craschR(scores2, item2, SEcons, writeout = TRUE)
View(SEcons)
View(SEitem)
View(SEcons)
results1 = craschR(scores1, item1, SEcons[1,], writeout = TRUE)
results2 = craschR(scores2, item2, SEcons[1,], writeout = TRUE)
Split.halves(results1, results2)
consInfo = SEcons
consInfo$cons.ID
itemInfo$cons.ID
itemInfor = SEitem
itemInfo$cons.ID
rm(itemInfor)
itemInfo = SEitem
itemInfo$cons.ID
(!(all(consInfo$cons.ID %in% itemInfo$cons.ID)))
(!(all(itemInfo$cons.ID %in% consInfo$cons.ID)))
View(itemInfo)
View(item1)
itemInfo = item1
(!(all(itemInfo$cons.ID %in% consInfo$cons.ID)))
(!(all(consInfo$cons.ID %in% itemInfo$cons.ID)))
consInfo$cons.ID
which(consInfo$cons.ID %in% itemInfo$cons.ID)
consInfo$long.name[which(consInfo$cons.ID %in% itemInfo$cons.ID)]
if (!(all(consInfo$cons.ID %in% itemInfo$cons.ID))) {
stop(paste('The construct',
consInfo$long.name[which(consInfo$cons.ID %in% itemInfo$cons.ID)],
'has no items mapped to it. Remove its row from the consInfo object.'))
}
stop(paste('The construct',
consInfo$long.name[which(consInfo$cons.ID %in% itemInfo$cons.ID)],
'has no items mapped to it. \n
Remove its row from the consInfo object.'))
stop(paste('The construct',
consInfo$long.name[which(consInfo$cons.ID %in% itemInfo$cons.ID)],
'has no items mapped to it. \n',
'Remove its row from the consInfo object.'))
stop(paste('The construct',
consInfo$long.name[which(consInfo$cons.ID %in% itemInfo$cons.ID)],
'has no items mapped to it. \n',
'      Remove its row from the consInfo object.'))
consInfo = SEcons[,1]
itemInfo = SEitem
(!(all(itemInfo$cons.ID %in% consInfo$cons.ID)))
itemInfo$cons.ID
consInfo$cons.ID
consInfo = SEcons[1,]
consInfo$cons.ID
which(itemInfo$cons.ID %in% consInfo$cons.ID)
itemInfo$item.name[which(itemInfo$cons.ID %in% consInfo$cons.ID)]
if (!(all(itemInfo$cons.ID %in% consInfo$cons.ID))) {
stop(paste('Invalid cons.ID on items: ',
itemInfo$item.name[which(itemInfo$cons.ID %in% consInfo$cons.ID)]))
}
stop(paste('Invalid cons.ID on items: ',
paste(itemInfo$item.name[which(itemInfo$cons.ID %in% consInfo$cons.ID)], collapse = ", ")))
stop(paste('No matching cons.ID in consInfo object for items:\n',
paste(itemInfo$item.name[which(itemInfo$cons.ID %in% consInfo$cons.ID)],
collapse = ", ")))
stop(paste('No matching cons.ID in consInfo object for items:\n      ',
paste(itemInfo$item.name[which(itemInfo$cons.ID %in% consInfo$cons.ID)],
collapse = ", ")))
rm(list = ls())
cons = read.csv("C:/Users/Amy/Desktop/Emily/bugs/ArgCons.csv", stringsAsFactors = FALSE)
item = read.csv("C:/Users/Amy/Desktop/Emily/bugs/ARGitems.csv", stringsAsFactors = FALSE)
scores = read.csv("C:/Users/Amy/Desktop/Emily/bugs/ARGwide.csv", row.names = 1, stringsAsFactors = FALSE)
View(cons)
View(item)
View(scores)
itemInfo = item
consInfo = cons
varsInfo = NULL
estPackage="TAM"
longFormat = FALSE
persMethod = "EAP"
retainOrig = FALSE
missingAs0 = FALSE
consecutive = FALSE
writeout = FALSE
if ( is.character(scores) ) {
if ( !grepl(".csv$",scores) ) {
stop("scores file must end with '.csv'")
}
scores <- data.frame(read.csv(scores, stringsAsFactors = FALSE, row.names = 1))
}
if ( is.character(itemInfo) ) {
if ( !grepl(".csv$",itemInfo) ) {
stop("itemInfo file must end with '.csv'")
}
itemInfo <- data.frame(read.csv(itemInfo,stringsAsFactors=FALSE))
}
if ( is.character(consInfo) ) {
if ( !grepl(".csv$",consInfo) ) {
stop("consInfo file must end with '.csv'")
}
consInfo <- data.frame(read.csv(consInfo,stringsAsFactors=FALSE))
}
if ( is.character(varsInfo) ) {
if ( !grepl(".csv$",varsInfo) ) {
stop("varsInfo file must end with '.csv'")
}
varsInfo <- data.frame(read.csv(varsInfo))
}
if (!(all(consInfo$cons.ID %in% itemInfo$cons.ID))) {
stop(paste('The construct',
consInfo$long.name[which(consInfo$cons.ID %in% itemInfo$cons.ID)],
'has no items mapped to it. \n',
'      Remove its row from the consInfo object.'))
}
# check that all items are mapped to a construct in consInfo
if (!(all(itemInfo$cons.ID %in% consInfo$cons.ID))) {
stop(paste('No matching cons.ID in consInfo object for item(s):\n      ',
paste(itemInfo$item.name[which(itemInfo$cons.ID %in% consInfo$cons.ID)],
collapse = ", ")))
}
if ( estPackage == "TAM"  ) { requireNamespace("TAM", quietly = TRUE) }
startTime = date()
# addition of any input/argument also requires an update of the functions in
#   internalChecks.R
checkInput(scores, itemInfo, consInfo, varsInfo, estPackage, retainOrig,
missingAs0, longFormat, persMethod, consecutive, writeout)
checkWrite(writeout, fileSuffix)
if ( longFormat ) {
wide <- reshape(scores[c("resp.ID","item.ID","cat")],timevar="item.ID",
v.names="cat",idvar="resp.ID",direction="wide")
row.names(wide) = wide$resp.ID
wide$resp.ID = NULL
colnames(wide) = itemInfo$item.name[itemInfo$item.ID ==
as.numeric(gsub("cat.","",colnames(wide)))]
} else {
wide <- scores
}
wide = wide[itemInfo$item.name]
checkObjs(wide, itemInfo, consInfo, varsInfo, estPackage, retainOrig,
missingAs0, longFormat, persMethod, consecutive, writeout,
imageType)
I <- nrow(itemInfo) # number of items
N <- nrow(wide)     # number of persons
D <- nrow(consInfo) # number of dimensions
if ( missingAs0 ) {
for (i in 1:I) {
wide[is.na(wide[,i]),i] =
min(which(as.logical(itemInfo[i,6:ncol(itemInfo)])))
}
}
scoresOrig <- wide
for (i in c(1:I)) {
J = sort(unique(wide[,i]),decreasing=FALSE)
for (j in c(1:length(J))) {
wide[,i][wide[,i]==J[j]] = j - 1
}
}
noVar(wide)
as.numeric(c(which(apply(wide,2,function(x) length(unique(x))) == 1)))
apply(wide,2,function(x) length(unique(x))) == 1)
apply(wide,2,function(x) length(unique(x))) == 1))
apply(wide,2,function(x) length(unique(x)) == 1))
apply(wide,2,function(x) length(unique(x)) == 1)
as.numeric(c(which(apply(wide,2,function(x) length(unique(x)) == 1))))
apply(wide, 2, function(x) { length(unique(x)) == 1 })
apply(wide, 2, function(x) { length(unique(x)) })
View(wide)
?unique
apply(wide, 2, function(x) { length(unique(x[!is.na(x)])) == 1 })
which(apply(wide, 2, function(x) { length(unique(x[!is.na(x)])) == 1 }))
as.numeric(which(apply(wide, 2, function(x) { length(unique(x[!is.na(x)])) == 1 })))
dropped = noVar(wide)
if (length(dropped) > 0) {
warning(length(dropped),
" item(s) showed no response variability and were dropped from analysis:\n",
paste(paste("    ",itemInfo$item.name[dropped]," (",
itemInfo$item.ID[dropped],")",sep=""),collapse="\n"),
"\n")
itemInfo = itemInfo[-dropped,]
wide = wide[,-dropped]
}
length(dropped) > 0
devtools::load_all()
dropped = noVar(wide)
if (length(dropped) > 0) {
warning(length(dropped),
" item(s) showed no response variability and were dropped from analysis:\n",
paste(paste("    ",itemInfo$item.name[dropped]," (",
itemInfo$item.ID[dropped],")",sep=""),collapse="\n"),
"\n")
itemInfo = itemInfo[-dropped,]
wide = wide[,-dropped]
}
test = craschR(wide, itemInfo = item, consInfo = cons, writeout = FALSE)
View(scores)
View(itemInfo)
View(item)
View(scores)
which(!(item$item.name %in% row.names(scores)))
which(!(item$item.name %in% colnames(scores)))
rm(list=ls())
cons = read.csv("C:/Users/Amy/Desktop/Emily/bugs/ArgCons.csv", stringsAsFactors = FALSE)
item = read.csv("C:/Users/Amy/Desktop/Emily/bugs/ARGitems.csv", stringsAsFactors = FALSE)
scores = read.csv("C:/Users/Amy/Desktop/Emily/bugs/ARGwide.csv", row.names = 1, stringsAsFactors = FALSE)
devtools::load_all()
craschR(wide, itemInfo = item, consInfo = cons)
craschR(scores, itemInfo = item, consInfo = cons)
devtools::load_all()
craschR(scores, itemInfo = item, consInfo = cons)
devtools::load_all()
craschR(scores, itemInfo = item, consInfo = cons)
devtools::load_all()
craschR(scores, itemInfo = item, consInfo = cons)
devtools::load_all()
craschR(scores, itemInfo = item, consInfo = cons)
test <- craschR(scores, itemInfo = item, consInfo = cons)
test <- craschR(scores, itemInfo = item, consInfo = cons, consecutive = TRUE)
View(item)
View(cons)
results = test
item.scores(test)
results = test
dim = NULL
freqs = TRUE
palette = "BASS"
writeout = FALSE
checkResults(results)
checkDim(dim, results$consInfo)
origPar = par(no.readonly = TRUE) # so graphical parameters can be reset after
par(mai=c(1.36,1.093333,1.093333,0.56),
mar=c(5.1,4.1,4.1,2.1),
xpd=FALSE)
tables <- list()
table(results$scoresOrig)
View(scoresOrig)
View(results$scoresOrig)
table(c(results$scoresOrig))
as.vector(scoresOrig)
as.vector(results$scoresOrig)
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else {
D <- dim
}
D
d = 1
cons <- results$consInfo[d,]
I <- sum(results$itemInfo$cons.ID == cons$cons.ID)
scores <- reshape(data.frame(as.matrix(results$scoresOrig[,
which(results$itemInfo$cons.ID == results$consInfo$cons.ID[d])])),
varying = list(1:I), idvar = "person",
direction = "long", timevar = "item", v.names = "score")
View(scores)
table(scores$score)
unique(scores$score)
order(unique(scores$score))
sort(unique(scores$score))
K <- ncol(cons) - 3
if ( freqs ) {
tograph <- table(scores$score, scores$item, useNA="no")
} else {
tograph <- prop.table(table(scores$score, scores$item, useNA="no"),
margin = 2)
}
dimnames(tograph) <- list(cons[4:ncol(cons)][sort(unique(scores$score))],
results$itemInfo$item.name[
which(results$itemInfo$cons.ID == results$consInfo$cons.ID[d])])
toGraph
tograph
devtools::load_all()
item.scores(test)
devtools::build()
