toGraph
results$empties
toGraph
sapply(1:results$estSummary$I, function(x) {
# "remove" the empty categories
if (length(results$empties[[x]]) > 0) {
toGraph[x,results$empties[[x]]] = FALSE
}
# "remove" the first TRUE for each item
})
toGraph
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
toGraph[x,results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
}
toGraph
1:results$estSummary$I
length(results$empties[[i]]) > 0
i=24
length(results$empties[[i]]) > 0
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
toGraph[i,results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
}
toGraph
itemThres
itemInfo
toGraph
cbind(itemThres,toGraph)
cbind(itemThres,toGraph,itemInfo[,6:ncol(itemInfo)])
toGraph <- itemInfo[,6:ncol(itemInfo)]
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
toGraph[i,results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
}
cbind(itemThres,toGraph,itemInfo[,6:ncol(itemInfo)])
?apply
?axis
x = toGraph[1,]
min(which(x))
x
toGraph <- as.logical(itemInfo[,6:ncol(itemInfo)])
toGraph <- matrix(itemInfo[,6:ncol(itemInfo)])
toGraph
as.matrix(itemInfo[,6:ncol(itemInfo)])
toGraph <- as.matrix(itemInfo[,6:ncol(itemInfo)])
x = toGraph[1,]
min(which(x))
apply(toGraph, 1, function(x) {
x[min(which(x))] = FALSE
})
apply(toGraph, 1, function(x) {
min(which(x))
})
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
toGraph[i,results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
apply(toGraph, 1, function(x) {
min(which(x))
})
}
apply(toGraph, 1, function(x) {
min(which(x))
})
min(which(toGraph[i,]))
i=16
min(which(toGraph[i,]))
toGraph <- as.matrix(itemInfo[,6:ncol(itemInfo)])
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
toGraph[i, results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
toGraph[i, min(which(toGraph[i,]))] = FALSE
}
toGraph
cbind(toGraph,itemThres)
c(itemThres)
toGraph = toGraph[,-1]
toGraph
c(itemThres)
toGraph <- as.numeric(itemXcat)
rm(toGraph)
itemXcat <- as.matrix(itemInfo[,6:ncol(itemInfo)])
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
itemXcat[i, results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
itemXcat[i, min(which(itemXcat[i,]))] = FALSE
}
itemXcat = itemXcat[,-1]
toGraph <- as.numeric(itemXcat)
toGraph
toGraph[itemXcat] * c(itemThres)[!is.na(c(itemThres))]
toGraph[itemXcat] <- c(itemThres)[!is.na(c(itemThres))]
toGraph
toGraph <- matrix(dim = dim(itemXcat))
?matrix
itemXcat = itemXcat[,-1]
toGraph <- matrix(nrow = nrow(itemXcat), ncol = ncol(itemXcat))
toGraph[itemXcat] <- c(itemThres)[!is.na(c(itemThres))]
sum(itemXcat)
length(c(itemThres)[!is.na(c(itemThres))])
cbind(itemThres,itemXcat)
itemXcat <- as.matrix(itemInfo[,6:ncol(itemInfo)])
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
itemXcat[i, results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
itemXcat[i, min(which(itemXcat[i,]))] = FALSE
}
itemXcat = itemXcat[,-1]
cbind(itemThres,itemXcat)
sum(itemXcat)
toGraph <- matrix(nrow = nrow(itemXcat), ncol = ncol(itemXcat))
toGraph[itemXcat] <- c(itemThres)[!is.na(c(itemThres))]
toGraph
toGraph <- matrix(nrow = ncol(itemXcat), ncol = nrow(itemXcat))
toGraph[itemXcat] <- c(itemThres)[!is.na(c(itemThres))]
toGraph
toGraph <- matrix(nrow = ncol(itemXcat), ncol = nrow(itemXcat))
toGraph[itemXcat] <- c(t(itemThres))[!is.na(c(itemThres))]
toGraph
toGraph <- matrix(nrow = ncol(itemXcat), ncol = nrow(itemXcat))
toGraph[itemXcat] <- c(t(itemThres))[!is.na(c(t(itemThres)))]
toGraph
c(t(itemThres))[!is.na(c(t(itemThres)))]
toGraph <- matrix(nrow = nrow(itemXcat), ncol = ncol(itemXcat))
toGraph[itemXcat] <- c(t(itemThres))[!is.na(c(t(itemThres)))]
toGraph
itemXcat = t(itemXcat)
toGraph <- matrix(nrow = nrow(itemXcat), ncol = ncol(itemXcat))
toGraph[itemXcat] <- c(t(itemThres))[!is.na(c(t(itemThres)))]
toGraph
wrightMap(toGraph)
?wrightMap
wrightMap(results$persPars,toGraph)
wrightMap(results$persPars,itemThres)
?index
cons <- results$consInfo$short.name[D[i]]
i = 1
cons <- results$consInfo$short.name[D[i]]
paste(cons, "Wright Map")
cons <- NULL
paste(cons, "Wright Map")
paste0(results$consInfo$short.name[D[i]], " ")
paste0(cons, "Wright Map")
xLabel <- results$consInfo
rm(xLabel)
results$consInfo
toGraph
itemThres
itemInfo$item.name[thresList[[i]]]
results$consInfo[D[i], 5:ncol(results$consInfo)]
results$consInfo[D[i], 4:ncol(results$consInfo)]
colnames(results$persPars)
toGraph
thresLabel <- itemInfo$item.name
thresLabel
matrix(rep(colnames(results$persPars), each = nrow(toGraph),
nrow = nrow(toGraph), ncol = ncol(toGraph),
byrow = TRUE)
)
matrix(rep(colnames(results$persPars), each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph),
byrow = TRUE)
matrix(rep(colnames(itemInfo$item.name), each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph),
byrow = TRUE)
matrix(rep(itemInfo$item.name, each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph),
byrow = TRUE)
matrix(rep(itemInfo$item.name, each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph))
rm(list = ls())
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
results = AMY
dim = NULL
itemOrder = "item"
palette = "BASS"
writeout = FALSE
imageType = "pdf"
filePrefix = NULL
if (itemOrder == "construct") {
consecutive = TRUE
} else {
consecutive = results$estSummary$consecutive
}
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else {
D <- dim
}
if (itemOrder != "item" & itemOrder != "construct") {
stop('Specify valid itemOrder.  Choose "item", "construct", or provide a numeric vector.')
}
itemInfo <- results$itemInfo
itemThres <- results$itemThres
consecutive
thresList <- list()
for (i in 1:length(D)) {
# get the indices for the items on each construct
thresList[[i]] <- which(itemInfo$cons.ID == results$consInfo$cons.ID[D[i]])
}
toGraph <- itemThres
if (palette == "BASS") {
color <- c("black", "#80b1d3")
} else if (palette %in% row.names(brewer.pal.info)) {
color <- RColorBrewer::brewer.pal(3, palette)
} else {
stop('Please choose an allowed color palette - "BASS" or any RColorBrewer palette.')
}
for (i in 1:length(thresList)) {
if (consecutive) {
thetas <- results$persPars[,D[i]]
cons <- consLabel <- paste0(results$consInfo$short.name[D[i]], " ")
thresLabel <- matrix(rep(itemInfo$item.name, each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph))
} else {
thetas <- results$persPars
cons <- thresLabel <- NULL
consLabel <- colnames(results$persPars)
}
if (itemOrder == "construct") {
xLabel <- results$consInfo[D[i], 5:ncol(results$consInfo)]
} else {
xLabel <- itemInfo$item.name[thresList[[i]]]
}
if (writeout) {
if (itemOrder = "item") {
fileName <- "-itemorder"
} else if (itemOrder = "construct") {
fileName <- "-constructorder"
} else {
fileName <- "-customorder"
}
if (length(thresList)==1) {
index <- NULL
} else {
index <- D[i]
}
eval(parse(text = paste0(imageType, "('", filePrefix, "WM", fileName,
index, ".", imageType, "')")))
}
wrightMap(thetas = thetas,
thresholds = toGraph[thresList[[i]],],
main.title = paste0(cons, "Wright Map"),
show.thr.lab = ncol(toGraph) > 1,
axis.items = "",
label.items = xLabel,
label.items.srt = 45,
dim.names = consLabel,
thr.sym.pch = 21,
thr.sym.col.fg = color[1],
thr.sym.col.bg = color[2],
return.thresholds = FALSE)
if (writeout) {
dev.off()
}
}
if (consecutive) {
thetas <- results$persPars[,D[i]]
cons <- consLabel <- paste0(results$consInfo$short.name[D[i]], " ")
thresLabel <- matrix(rep(itemInfo$item.name, each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph))
} else {
thetas <- results$persPars
cons <- thresLabel <- NULL
consLabel <- colnames(results$persPars)
}
if (itemOrder == "construct") {
xLabel <- results$consInfo[D[i], 5:ncol(results$consInfo)]
} else {
xLabel <- itemInfo$item.name[thresList[[i]]]
}
xLabel
if (itemOrder = "item") {
fileName <- "-itemorder"
} else if (itemOrder = "construct") {
fileName <- "-constructorder"
} else {
fileName <- "-customorder"
}
if (length(thresList)==1) {
index <- NULL
} else {
index <- D[i]
}
if (itemOrder == "item") {
fileName <- "-itemorder"
} else if (itemOrder == "construct") {
fileName <- "-constructorder"
} else {
fileName <- "-customorder"
}
if (length(thresList)==1) {
index <- NULL
} else {
index <- D[i]
}
eval(parse(text = paste0(imageType, "('", filePrefix, "WM", fileName,
index, ".", imageType, "')")))
dev.off()
dev.off()
dev.off()
dev.off()
wrightMap(thetas = thetas,
thresholds = toGraph[thresList[[i]],],
main.title = paste0(cons, "Wright Map"),
show.thr.lab = ncol(toGraph) > 1,
axis.items = "",
label.items = xLabel,
label.items.srt = 45,
dim.names = consLabel,
thr.sym.pch = 21,
thr.sym.col.fg = color[1],
thr.sym.col.bg = color[2],
return.thresholds = FALSE)
if (itemOrder == "construct") {
xLabel <- results$consInfo[D[i], 5:ncol(results$consInfo)]
thresPos <- c(2,4)
} else {
xLabel <- itemInfo$item.name[thresList[[i]]]
thresPos <- 2
}
wrightMap(thetas = thetas,
thresholds = toGraph[thresList[[i]],],
main.title = paste0(cons, "Wright Map"),
show.thr.lab = ncol(toGraph) > 1,
axis.items = "",
label.items = xLabel,
label.items.srt = 45,
dim.names = consLabel,
thr.sym.pch = 21,
thr.sym.col.fg = color[1],
thr.sym.col.bg = color[2],
thr.lab.pos = thresPos,
return.thresholds = FALSE)
rm(list=ls())
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
results = AMY
dim = NULL
itemOrder = "construct"
palette = "BASS"
writeout = FALSE
if (itemOrder == "construct") {
consecutive = TRUE
} else {
consecutive = results$estSummary$consecutive
}
if (is.null(dim)) {
D <- 1:results$estSummary$D
} else {
D <- dim
}
if (is.numeric(itemOrder)) {
itemInfo <- results$itemInfo[itemOrder,]
itemThres <- results$itemThres[itemOrder,]
} else {
if (itemOrder != "item" & itemOrder != "construct") {
stop('Specify valid itemOrder.  Choose "item", "construct", or provide a numeric vector.')
}
itemInfo <- results$itemInfo
itemThres <- results$itemThres
}
if (consecutive) {
thresList <- list()
for (i in 1:length(D)) {
# get the indices for the items on each construct
thresList[[i]] <- which(itemInfo$cons.ID == results$consInfo$cons.ID[D[i]])
}
} else {
thresList <- list(1:results$estSummary$I)
}
itemXcat <- as.matrix(itemInfo[,6:ncol(itemInfo)])
for (i in 1:results$estSummary$I) {
# "remove" the empty categories
if (length(results$empties[[i]]) > 0) {
itemXcat[i, results$empties[[i]]] = FALSE
}
# "remove" the first TRUE for each item
itemXcat[i, min(which(itemXcat[i,]))] = FALSE
}
itemXcat = t(itemXcat[,-1])
# fill in the thresholds
toGraph <- matrix(nrow = nrow(itemXcat), ncol = ncol(itemXcat))
toGraph[itemXcat] <- c(t(itemThres))[!is.na(c(t(itemThres)))]
toGraph
if (palette == "BASS") {
color <- c("black", "#80b1d3")
} else if (palette %in% row.names(brewer.pal.info)) {
color <- RColorBrewer::brewer.pal(3, palette)
} else {
stop('Please choose an allowed color palette - "BASS" or any RColorBrewer palette.')
}
i = 1
thetas <- results$persPars[,D[i]]
cons <- consLabel <- paste0(results$consInfo$short.name[D[i]], " ")
thresLabel <- matrix(rep(itemInfo$item.name, each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph))
thetas
cons
thresLabel
if (consecutive) {
thetas <- results$persPars[,D[i]]
cons <- consLabel <- paste0(results$consInfo$short.name[D[i]], " ")
thresLabel <- matrix(rep(itemInfo$item.name, each = nrow(toGraph)),
nrow = nrow(toGraph), ncol = ncol(toGraph))
} else {
thetas <- results$persPars
cons <- thresLabel <- NULL
consLabel <- colnames(results$persPars)
}
if (itemOrder == "construct") {
xLabel <- results$consInfo[D[i], 5:ncol(results$consInfo)]
thresPos <- c(2,4)
} else {
xLabel <- itemInfo$item.name[thresList[[i]]]
thresPos <- 2
}
if (itemOrder == "item") {
fileName <- "-itemorder"
} else if (itemOrder == "construct") {
fileName <- "-constructorder"
} else {
fileName <- "-customorder"
}
if (length(thresList)==1) {
index <- NULL
} else {
index <- D[i]
}
wrightMap(thetas = thetas,
thresholds = toGraph[thresList[[i]],],
main.title = paste0(cons, "Wright Map"),
show.thr.lab = ncol(toGraph) > 1,
axis.items = "",
label.items = xLabel,
label.items.srt = 45,
dim.names = consLabel,
thr.sym.pch = 21,
thr.sym.col.fg = color[1],
thr.sym.col.bg = color[2],
thr.lab.pos = thresPos,
return.thresholds = FALSE)
wrightMap(thetas = thetas,
thresholds = toGraph[,thresList[[i]]],
main.title = paste0(cons, "Wright Map"),
show.thr.lab = ncol(toGraph) > 1,
axis.items = "",
label.items = xLabel,
label.items.srt = 45,
dim.names = consLabel,
thr.sym.pch = 21,
thr.sym.col.fg = color[1],
thr.sym.col.bg = color[2],
thr.lab.pos = thresPos,
return.thresholds = FALSE)
eval(parse(text = paste0(imageType, "('", filePrefix, "WM", fileName,
index, ".", imageType, "'), width = ", imgWidth,
" , height = 7")))
imageType = "pdf"
filePrefix = NULL
index = 1
eval(parse(text = paste0(imageType, "('", filePrefix, "WM", fileName,
index, ".", imageType, "'), width = ", imgWidth,
" , height = 7")))
imgWidth <- min(14, length(thresList[[i]]))
eval(parse(text = paste0(imageType, "('", filePrefix, "WM", fileName,
index, ".", imageType, "'), width = ", imgWidth,
" , height = 7")))
eval(parse(text = paste0(imageType, "('", filePrefix, "WM", fileName,
index, ".", imageType, "', width = ", imgWidth,
" , height = 7)")))
dev.off()
dev.off()
ncol(results$consInfo)
colnames(results$consInfo)
rm(list=ls())
devtools::load_all()
devtools::load_all()
AMY <- craschR(scores = AMYwide, itemInfo = AMYitem, consInfo = AMYcons,
varsInfo = AMYvars, estPackage = "TAM", retainOrig = TRUE,
consecutive = TRUE, writeout = FALSE)
?wm
wm(AMY)
wm(AMY, itemOrder = "construct")
devtools::document()
devtools::load_all()
?wm
wm(AMY, itemOrder = 1:4)
